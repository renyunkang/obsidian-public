<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ryken の garden on</title><link>https://www.ryken.cloud/</link><description>Recent content in ryken の garden on</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 25 May 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://www.ryken.cloud/index.xml" rel="self" type="application/rss+xml"/><item><title>1.性能测试无法满足期望 - reuse</title><link>https://www.ryken.cloud/1.%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%97%A0%E6%B3%95%E6%BB%A1%E8%B6%B3%E6%9C%9F%E6%9C%9B-reuse/</link><pubDate>Wed, 13 Sep 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/1.%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%97%A0%E6%B3%95%E6%BB%A1%E8%B6%B3%E6%9C%9F%E6%9C%9B-reuse/</guid><description>在高并发、短连接的场景下，kube-proxy ipvs存在rs删除失败或是延迟高的问题，社区也有不少Issue反馈，比如 kube-proxy ipvs conn_reuse_mode setting causes errors with high load from single client。文本对这些问题进行了梳理，试图介绍产生这些问题的内部原因。由于能力有限，其中涉及内核部分，只能浅尝辄止。
背景 端口重用 一切问题来源于端口重用。在TCP四次挥手中有个TIME_WAIT的状态，作为先发送FIN包的一端，在接收到对端发送的FIN包后进入TIME_WAIT，在经过2MSL后才会真正关闭连接。TIME_WAIT状态的存在，一来可以避免将之前连接的延迟报文，作为当前连接的报文处理；二是可以处理最后一个ACK丢失带来的问题。
而在短连接、高并发的场景下，会出现大量的TIME-WAIT连接，导致资源无法及时释放。Linux中内核参数net.ipv4.tcp_tw_reuse提供了一种减少TIME-WAIT连接的方式，可以将TIME-WAIT连接的端口分配给新的TCP连接，来复用端口。
1 2 3 4 5 tcp_tw_reuse - BOOLEAN Allow to reuse TIME-WAIT sockets for new connections when it is safe from protocol viewpoint.</description></item><item><title>2. kube-proxy 跨 vlan 访问</title><link>https://www.ryken.cloud/2.-kube-proxy-%E8%B7%A8-vlan-%E8%AE%BF%E9%97%AE/</link><pubDate>Wed, 13 Sep 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/2.-kube-proxy-%E8%B7%A8-vlan-%E8%AE%BF%E9%97%AE/</guid><description>背景 使用 hybridnet 搭建的 vlan 环境在测试 svc 的连通性的时候发现了一个很疑惑的问题 实际搭建的环境如下： node22、node23、node24 三个节点均在 vlan 50；划分了 vlan53 和 vlan73 网络域后，会在 node22、node23 上创建相应的子接口。 位于node22、node23 上的 pod 在访问分布在 node24 的 pod 暴露的 svc 时，报错：</description></item><item><title>calico bandwidth 适配</title><link>https://www.ryken.cloud/calico-bandwidth-%E9%80%82%E9%85%8D/</link><pubDate>Wed, 13 Sep 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/calico-bandwidth-%E9%80%82%E9%85%8D/</guid><description>需求以及修改方式见：[[bandwidth 带宽限制]]
对于 bandwidth 编译之后，根据 [[github release]] 将编译生成的文件上传到 github release
重新编译 cni-plugin 镜像，将其中下载的 cni plugin 更换为自己维护的 cni 仓库 release 包</description></item><item><title>calico 网络策略</title><link>https://www.ryken.cloud/calico-%E7%BD%91%E7%BB%9C%E7%AD%96%E7%95%A5/</link><pubDate>Wed, 13 Sep 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/calico-%E7%BD%91%E7%BB%9C%E7%AD%96%E7%95%A5/</guid><description>Kubernetes NetworkPolicy： [[networkPolicy - 网络策略]] namespace 级别的网络策略 网络策略应用于 labelSelector 选取出的 pod 网络策略可以指定允许从哪些 pods 来、到哪些 pods 去、namespace 或者 cidr 的流量 网络策略可以指定协议(TCP/UDP/SCTP)，并指定特定的端口 Calico NetworkPolicy 扩展了 kubernetes networkpolicy</description></item><item><title>cilium 安装使用</title><link>https://www.ryken.cloud/cilium-%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/</link><pubDate>Wed, 13 Sep 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/cilium-%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/</guid><description>遇到的问题：
安装时 cluster name 不能含有 . https://github.com/cilium/cilium-cli/issues/490 国内环境使用 cilium-cli 安装失败 拉取镜像失败，能否指定镜像拉取？ 换用 helm 安装
1 2 3 4 5 6 helm repo add cilium https://helm.</description></item><item><title>ipvs</title><link>https://www.ryken.cloud/ipvs/</link><pubDate>Wed, 13 Sep 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/ipvs/</guid><description>LVS - Linux Virtual Server 的简称，kubernetes 中主要包含 ipvs + ipvsadm。 官方链接： The Linux Virtual Server Project - Linux Server Cluster for Load Balancing</description></item><item><title>ipvs 相关的内核参数</title><link>https://www.ryken.cloud/ipvs-%E7%9B%B8%E5%85%B3%E7%9A%84%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0/</link><pubDate>Wed, 13 Sep 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/ipvs-%E7%9B%B8%E5%85%B3%E7%9A%84%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0/</guid><description>ipvs 相关内核文档：
IPvs-sysctl — The Linux Kernel documentation 1. 参数 am_droprate 1 2 3 am_droprate - INTEGER default 10 It sets the always mode drop rate, which is used in the mode 3 of the drop_rate defense.</description></item><item><title>networkPolicy - 网络策略</title><link>https://www.ryken.cloud/networkPolicy-%E7%BD%91%E7%BB%9C%E7%AD%96%E7%95%A5/</link><pubDate>Wed, 13 Sep 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/networkPolicy-%E7%BD%91%E7%BB%9C%E7%AD%96%E7%95%A5/</guid><description>网络策略 | Kubernetes
https://kubernetes.io/docs/concepts/services-networking/network-policies/
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 apiVersion:networking.</description></item><item><title>TCP三次握手和四次挥手</title><link>https://www.ryken.cloud/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</link><pubDate>Wed, 13 Sep 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</guid><description>TCP三次握手和四次挥手 大量的 TIME_WAIT 状态 TCP 连接存在，其本质原因是什么？ 大量的短连接存在 特别是 HTTP 请求中，如果 connection 头部取值被设置为 close 时，基本都由「服务端」发起主动关闭连接 而，TCP 四次挥手关闭连接机制中，为了保证 ACK 重发和丢弃延迟数据，设置 time_wait 为 2 倍的 MSL（报文最大存活时间） TIME_WAIT 状态：</description></item><item><title>git sync</title><link>https://www.ryken.cloud/git-sync/</link><pubDate>Fri, 08 Sep 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/git-sync/</guid><description>由于新的需求在仓库(upstream)新建了一个分支new，然而我fork的origin(远程个人仓库，非电脑中的本地仓库)中没有这个分支，我需要在new分支上进行开发并与upstream追踪，如何将新分支new插入origin中了，步骤如下: 1：创建并切换到新的上游分支的本地版本 git checkout -b new upstream/new； 2：将新的分支推送到个人远程仓库 git push -u origin new,-u跟踪指定的远程；
同步其他提交
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 git remote add upstream https://github.</description></item><item><title/><link>https://www.ryken.cloud/cni-network/</link><pubDate>Thu, 07 Sep 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/cni-network/</guid><description>[[bandwidth 带宽限制]] [[手动创建 netns + 跨主机通信]] [[multus-cni]] [[networkPolicy - 网络策略]] [[calico]]</description></item><item><title>bandwidth 带宽限制</title><link>https://www.ryken.cloud/bandwidth-%E5%B8%A6%E5%AE%BD%E9%99%90%E5%88%B6/</link><pubDate>Thu, 07 Sep 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/bandwidth-%E5%B8%A6%E5%AE%BD%E9%99%90%E5%88%B6/</guid><description>bandwidth 插件 CNI-bandwidth
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 { &amp;#34;cniVersion&amp;#34;: &amp;#34;0.</description></item><item><title>calico 运营文档</title><link>https://www.ryken.cloud/calico-%E8%BF%90%E8%90%A5%E6%96%87%E6%A1%A3/</link><pubDate>Thu, 07 Sep 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/calico-%E8%BF%90%E8%90%A5%E6%96%87%E6%A1%A3/</guid><description>新增 or 扩容 ippool 固定 ip ns 与 subnet 绑定 calico 限速 calico 的 tunnel 地址会自动分配 迁移 ippool 的容量准备 blockSize 应该如何取值 kubesphere 集成了cni 的 ippool 和 网络策略，ks 在 cni 基础之上封装了一层，用于屏蔽不同 cni 底层实现的，现阶段版本中底层中主要使用了 calico。</description></item><item><title>cnitool</title><link>https://www.ryken.cloud/cnitool/</link><pubDate>Thu, 07 Sep 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/cnitool/</guid><description>官方文档链接：
https://www.cni.dev/docs/cnitool/ cnitool 是一个执行cni 配置的简易程序，可以在已经创建的网络命名空间内添加、删除 interface
环境变量 NETCONFPATH：配置文件路径目录，默认为 /etc/cni/net.d。cnitool 在给定目录中搜索扩展名为 *.conf 或 *.json 的 CNI 配置文件。它加载此目录中的所有 CNI 配置文件，如果找到具有给 cnitool 的网络名称的 CNI 配置，则返回相应的 CNI 配置，否则返回 nil CNI_PATH：检索 cni 可执行文件路径 安装 1 2 go get github.</description></item><item><title>github release</title><link>https://www.ryken.cloud/github-release/</link><pubDate>Thu, 07 Sep 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/github-release/</guid><description>指导文档：
发布 assets - GitHub 文档 Release CNI Plugins v1.3.0 · renyunkang/plugins (github.com) apt-get install gridsite-clients</description></item><item><title>kubernetes document</title><link>https://www.ryken.cloud/kubernetes-document/</link><pubDate>Thu, 07 Sep 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/kubernetes-document/</guid><description>官方文档 repo：
Kubernetes website and documentation repo grc images - Container Registry</description></item><item><title>Service NodePort</title><link>https://www.ryken.cloud/Service-NodePort/</link><pubDate>Thu, 07 Sep 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/Service-NodePort/</guid><description>kubernetes version state v1.20 alpha v1.22 beta, the feature gate feature switch needs to be turned on at the same time v1.</description></item><item><title>安装</title><link>https://www.ryken.cloud/%E5%AE%89%E8%A3%85/</link><pubDate>Thu, 07 Sep 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E5%AE%89%E8%A3%85/</guid><description>安装：curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh 卸载：rustup self uninstall 升级：rustup update 安装后的验证： rustc --version 运行本地文档：rustup doc 官方文档链接：https://www.rust-lang.org/learn/get-started
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 root@node:~# curl --proto &amp;#39;=https&amp;#39; --tlsv1.</description></item><item><title>安装 calico</title><link>https://www.ryken.cloud/%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</link><pubDate>Thu, 07 Sep 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</guid><description>官网 About Calico (tigera.io)
安装 calico calicoctl 使用calicoctl 可以使用calico 的更多的功能，calicoctl 用于管理 Calico 策略和配置，以及查看详细的集群状态。
API groups 所有 Kubernetes 资源都属于一个 API 组。 API 组由资源的 apiVersion 指定。Calico 使用 projectcalico.</description></item><item><title>build record</title><link>https://www.ryken.cloud/build-record/</link><pubDate>Fri, 01 Sep 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/build-record/</guid><description>build 工具包 go 安装包下载地址：
wget https://studygolang.com/dl/golang/go1.17.6.linux-amd64.tar.gz 1 2 3 4 5 6 7 8 # 配置环境 cat &amp;lt;&amp;lt;EOF &amp;gt; /etc/profile.</description></item><item><title>kubekey 安装高可用集群</title><link>https://www.ryken.cloud/kubekey-%E5%AE%89%E8%A3%85%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4/</link><pubDate>Fri, 01 Sep 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/kubekey-%E5%AE%89%E8%A3%85%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4/</guid><description>k8s 的HA 用kubekey的话支持三种： 1. 外置 lb 2. 内置 haproxy （每个worker节点） 3. 内置 kube-vip （每个master节点）
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 apiVersion:kubekey.</description></item><item><title>使用 containerlab + kind 搭建 calico-tor</title><link>https://www.ryken.cloud/%E4%BD%BF%E7%94%A8-containerlab-+-kind-%E6%90%AD%E5%BB%BA-calico-tor/</link><pubDate>Fri, 01 Sep 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E4%BD%BF%E7%94%A8-containerlab-+-kind-%E6%90%AD%E5%BB%BA-calico-tor/</guid><description>1. 使用 kind 创建 node 节点 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 kind:Clustername:clusterapiVersion:kind.</description></item><item><title>升级 calico + calico bgp filter 配置</title><link>https://www.ryken.cloud/%E5%8D%87%E7%BA%A7-calico-+-calico-bgp-filter-%E9%85%8D%E7%BD%AE/</link><pubDate>Fri, 01 Sep 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E5%8D%87%E7%BA%A7-calico-+-calico-bgp-filter-%E9%85%8D%E7%BD%AE/</guid><description>升级 calico 官方文档： Upgrade Calico on Kubernetes | Calico Documentation (tigera.io)
对于 kk 安装的集群，默认使用 calico manifest 安装，因此依照官方文档的使用 manifest 的方案升级：  https://docs.</description></item><item><title>k3s + rancher 安装</title><link>https://www.ryken.cloud/k3s-+-rancher-%E5%AE%89%E8%A3%85/</link><pubDate>Fri, 25 Aug 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/k3s-+-rancher-%E5%AE%89%E8%A3%85/</guid><description>文档链接：
安装在docker： https://oldj.net/article/2022/04/17/install-k3s-and-rancher/ 安装到k3s 中： https://blog.lv5.moe/p/use-k3s-to-build-homelab-based-on-kubernetes rancher 官方文档： https://ranchermanager.docs.rancher.com/zh/ https://ranchermanager.docs.rancher.com/v2.5/pages-for-subheaders/load-balancer-and-ingress-controller 安装 k3s：[[k3s 多节点安装]] 安装 rancher：
使用 helm 安装</description></item><item><title>k3s 多节点安装</title><link>https://www.ryken.cloud/k3s-%E5%A4%9A%E8%8A%82%E7%82%B9%E5%AE%89%E8%A3%85/</link><pubDate>Fri, 25 Aug 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/k3s-%E5%A4%9A%E8%8A%82%E7%82%B9%E5%AE%89%E8%A3%85/</guid><description>项目地址： https://github.com/k3s-io/k3s/releases 文档地址： https://docs.k3s.io/zh/
k3s 架构 多节点安装 安装 server 节点 如果不要多节点部署实现高可用，可以禁用 servicelb 组件。traefik 虽然是 K3s 自带的网络组件，但是其默认会占用 80 和 443 端口，也可以禁用。</description></item><item><title>perf 性能分析</title><link>https://www.ryken.cloud/perf-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</link><pubDate>Thu, 10 Aug 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/perf-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</guid><description>[[网卡多队列 + 中断绑定]]
Wiki - Linux 效能分析工具: Perf (ncku.edu.tw) 网络测试工具 一、iperf iperf是一个网络性能测试工具。iperf可以测试TCP和UDP带宽质量。iperf可以测量最大TCP带宽，具有多种参数和UDP特性。iperf可以报告带宽，延迟抖动和数据包丢失。利用iperf这一特性，可以用来测试一些网络设备如路由器，防火墙，交换机等的性能。
服务端10.74.148.74启动iperf3，监听端口12345，请求间断时间1s ~# iperf3 -s -p 12345 -i 1 客户端向10.</description></item><item><title>网卡命名规则</title><link>https://www.ryken.cloud/%E7%BD%91%E5%8D%A1%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99/</link><pubDate>Thu, 10 Aug 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E7%BD%91%E5%8D%A1%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99/</guid><description>GRUB_CMDLINE_LINUX_DEFAULT 有2个参数，决定网卡名字怎么显示：
biosdevname=1: em1 板载网卡 p3p4 pci网卡 net.ifnames=1 eno1 板载网卡 enp51s0f1 pci网卡 ens1 能热插拔的网卡 组合的情况</description></item><item><title>SDN 网络</title><link>https://www.ryken.cloud/SDN-%E7%BD%91%E7%BB%9C/</link><pubDate>Thu, 03 Aug 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/SDN-%E7%BD%91%E7%BB%9C/</guid><description>ASW （接入层交换机）数据交换模块接入交换机，接入云服务器，上行互联核心交换机DSW。 DSW （分布层交换机）：核心交换机，用于连接各个ASW接入交换机。 CSW （内网接入交换机）：接入用户内网骨干，实现云网络内外部的路由分发交互，包括VPC专线接入。CSW可以实现专线侧到XGW的VxLAN封装。 LSW （综合接入交换机）综合接入模块,云产品服务接入交换机，主要提供VPC和SLB等服务。各类云产品服务器（XGW/SLB/OPS）分别与两台LSW互联，通过OSPF交换路由信息；两台LSW之间通过iBGP交互路由信息；LSW与DSW、CSW之间通过eBGP交换路由信息。 云计算网络 ASW DSW CSW LSW - zzzzy09 - 博客园 (cnblogs.</description></item><item><title>calico 中的 proxy-arp</title><link>https://www.ryken.cloud/calico-%E4%B8%AD%E7%9A%84-proxy-arp/</link><pubDate>Wed, 02 Aug 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/calico-%E4%B8%AD%E7%9A%84-proxy-arp/</guid><description> /proc/sys/net/ipv4/conf/DEV/rp_filter =&amp;gt; 1：开启反向路径过滤，确认数据包来源，对于普通容器，IP基本无法伪装，但是如果是VM（Calico也支持VM），很容易伪装IP地址，所以为了安全打开这个选项。 /proc/sys/net/ipv4/conf/DEV/route_localnet =&amp;gt; 1：允许路由到本地。 /proc/sys/net/ipv4/neigh/DEV/proxy_delay =&amp;gt; 0：默认情况下，主机为了减少ARP风暴的可能，会延迟一段时间回复ARP包，这个选项关闭这个延迟。 /proc/sys/net/ipv4/conf/DEV/forwarding =&amp;gt; 1：允许转发数据包（如果不允许转发的话，那数据包就出不去主机了）。 上面是IPv4的情况，如果是IPv6的网络，则会设置：
/proc/sys/net/ipv6/conf/DEV/proxy_ndp =&amp;gt; 1：这个和proxy_arp是一样的。 /proc/sys/net/ipv4/conf/DEV/forwarding =&amp;gt; 1：同IPv4。</description></item><item><title>网络问题</title><link>https://www.ryken.cloud/%E7%BD%91%E7%BB%9C%E6%8E%92%E6%9F%A5/</link><pubDate>Fri, 28 Jul 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E7%BD%91%E7%BB%9C%E6%8E%92%E6%9F%A5/</guid><description>网络问题定位 dns 解析 svc-pod 转发不通(使用svcname 访问) 使用 svcip 可以访问 检查 dns 组件问题 使用 svcip 也不能访问 进一步检查 kube-proxy kube-proxy svc-pod 转发不通(直接使用 svc ip访问) 直接访问后端 pod-ip 可通 进一步检查 kube-proxy 规则问题 直接访问后端 pod-ip 不通 进一步检查 cni 问题 注意：不要使用 ping 命令测试 svcip icmp 是否连通，应该测试 svc 的四层转发是否连通 cni 跨节点pod-pod不通，pod-node不通 1.</description></item><item><title>动手实现 hybridnet - 原理</title><link>https://www.ryken.cloud/%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0-hybridnet-%E5%8E%9F%E7%90%86/</link><pubDate>Thu, 27 Jul 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0-hybridnet-%E5%8E%9F%E7%90%86/</guid><description>默认路由表
1 2 3 4 ~# ip rule 0: from all lookup local 32766: from all lookup main 32767: from all lookup default 1 2 3 4 5 6 7 8 9 ~# ip rule 0: from all lookup local 1: from all lookup 39999 2: from all lookup 40000 3: from all fwmark 0x20/0x20 lookup 40001 4: from 172.</description></item><item><title>动手实现 hybridnet - 实践</title><link>https://www.ryken.cloud/%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0-hybridnet-%E5%AE%9E%E8%B7%B5/</link><pubDate>Thu, 27 Jul 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0-hybridnet-%E5%AE%9E%E8%B7%B5/</guid><description>[[vlan 配置]] [[网卡 vlan]] [[手动创建 netns + 跨主机通信]] [[动手实现 hybirdnet.svg]]
规划的网段：
overlay：10.233.100.0/24 vlan： 10.10.11.0/24 10.10.20.0/24 添加 vlan 子接口</description></item><item><title>网络工具诊断</title><link>https://www.ryken.cloud/%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7%E8%AF%8A%E6%96%AD/</link><pubDate>Thu, 27 Jul 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7%E8%AF%8A%E6%96%AD/</guid><description>定位问题 出现问题时先定位是哪一部分发生了问题，dns 解析、kube-proxy、cni、底层网络 [[网络排查]]
在 pod 内通过 service name 进行访问其他业务服务时，出现访问不了的问题的排查思路
排查 dns 进入容器中使用 ping 或者 nslookup 查看域名解析是否正常，如果解析需要排查 DNS组件，有关 DNS 调试参考 调试 DNS 问题 | Kubernetes；如果解析正常进一步检查2</description></item><item><title>journalctl</title><link>https://www.ryken.cloud/journalctl/</link><pubDate>Fri, 21 Jul 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/journalctl/</guid><description>需更改设置,如上次系统崩溃，需要查看日志时，就要看上一次的启动日志。 journalctl -b -1
查看指定时间的日志 journalctl &amp;ndash;since=&amp;ldquo;2012-10-3018:17:16&amp;rdquo; journalctl &amp;ndash;since &amp;ldquo;20 minago&amp;rdquo; journalctl &amp;ndash;since yesterday journalctl &amp;ndash;since&amp;quot;2015-01-10&amp;quot; &amp;ndash;until &amp;ldquo;2015-01-11 03:00&amp;rdquo; journalctl &amp;ndash;since 09:00 &amp;ndash;until&amp;quot;1 hour ago&amp;quot; journalctl &amp;ndash;since&amp;quot;15:15&amp;quot; &amp;ndash;until now</description></item><item><title>hybridnet 自定义资源解释</title><link>https://www.ryken.cloud/hybridnet-%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B5%84%E6%BA%90%E8%A7%A3%E9%87%8A/</link><pubDate>Sun, 16 Jul 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/hybridnet-%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B5%84%E6%BA%90%E8%A7%A3%E9%87%8A/</guid><description>[[hybridnet 网络插件]]
资源 解释 networks 网络域 subnets 节点可用的网段资源 ipinstances ip 分配情况（只读） nodeinfoes 节点情况 vxlan 信息 每个 Network 至少需要有一个 Subnet 才能真正被使用 目前还不支持一个节点属于多个 Underlay Network，但是支持一个节点属于多个不同 type（比如 Overlay、Underlay）的 Network network network.</description></item><item><title>安装 bcc 工具包</title><link>https://www.ryken.cloud/%E5%AE%89%E8%A3%85-bcc-%E5%B7%A5%E5%85%B7%E5%8C%85/</link><pubDate>Sun, 16 Jul 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E5%AE%89%E8%A3%85-bcc-%E5%B7%A5%E5%85%B7%E5%8C%85/</guid><description>eunomia-bpf 是一个开源的 eBPF 动态加载运行时和开发工具链，它的目的是简化 eBPF 程序的开发、构建、分发、运行。它基于 libbpf 的 CO-RE 轻量级开发框架，支持通过用户态 WASM 虚拟机控制 eBPF 程序的加载和执行，并将预编译的 eBPF 程序打包为通用的 JSON 或 WASM 模块进行分发。</description></item><item><title>vscode + golang 环境</title><link>https://www.ryken.cloud/vscode-+-golang-%E7%8E%AF%E5%A2%83/</link><pubDate>Fri, 30 Jun 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/vscode-+-golang-%E7%8E%AF%E5%A2%83/</guid><description>环境配置 安装 golang vscode 连接上远程主机并安装 vscode server vscode 中安装 go 插件 安装 go 插件依赖的工具： ctrl+shift+p 调出命令面板，输入go install tools 选Go: Install/Update Tool 全选进行安装 使用 CGO 时，vscode 报错 1 go list failed to return CompiledGoFiles.</description></item><item><title>光大监控需求整理</title><link>https://www.ryken.cloud/%E5%85%89%E5%A4%A7%E7%9B%91%E6%8E%A7%E9%9C%80%E6%B1%82%E6%95%B4%E7%90%86/</link><pubDate>Thu, 08 Jun 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E5%85%89%E5%A4%A7%E7%9B%91%E6%8E%A7%E9%9C%80%E6%B1%82%E6%95%B4%E7%90%86/</guid><description>需求整理 网络监控的自证，从监控和日志上给证据。(带宽、吞吐率、延迟、抖动、错误的监控) 网络错误后、业务的快速恢复。方案上可以切换集群、网络自修复等。(快速恢复环境的最佳实践文档) 文档细化 文档 word 化，脑图 + 分析步骤 脑图中一些说明补充为命令的指导(如四层的网络检测怎么做，nc命令的简要说明) 数据的采集、日志的采集(一键收集日志的脚本) [长期] 云上网络监控的整体规划，不依赖具体cni。 KSE 4.</description></item><item><title>calico non-root + non-privileged 运行</title><link>https://www.ryken.cloud/calico-non-root-+-non-privileged-%E8%BF%90%E8%A1%8C/</link><pubDate>Fri, 02 Jun 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/calico-non-root-+-non-privileged-%E8%BF%90%E8%A1%8C/</guid><description>参照 operator 修改方式进行修改 privilege 运行是由于 Bidirectional 挂载必须为 privilege 模式
1 2 3 - mountPath:/sys/fs/mountPropagation:Bidirectionalname:sysfs 1 The DaemonSet &amp;#34;calico-node&amp;#34; is invalid: spec.</description></item><item><title>BGP 环境搭建</title><link>https://www.ryken.cloud/BGP-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</link><pubDate>Thu, 01 Jun 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/BGP-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</guid><description>安装工具 安装网桥工具 apt install -y bridge-utils 安装 bird apt-get install -y bird 修改配置文件 修改网络配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 source /etc/network/interfaces.</description></item><item><title>ip 地址</title><link>https://www.ryken.cloud/ip-%E5%9C%B0%E5%9D%80/</link><pubDate>Thu, 01 Jun 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/ip-%E5%9C%B0%E5%9D%80/</guid><description>IPv4 地址块 CIDR 范围 地址数 效用域 用途 0.0.0.0/8 0.0.0.0 – 0.255.255.255 16,777,216 软件 用于广播信息到当前主机 10.</description></item><item><title>calico ipam 过程</title><link>https://www.ryken.cloud/calico-ipam-%E8%BF%87%E7%A8%8B/</link><pubDate>Sat, 27 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/calico-ipam-%E8%BF%87%E7%A8%8B/</guid><description>calico ipam 相关 CRD 资源 资源名 介绍 ippool 用于 ipam 分配的 ip 池 ipamblock block 中 ip 分配信息等 blockaffinities 由 ippool 分割的细粒度的 ip 块以及 block 与节点的亲和性绑定关系 ipamconfigs 用于配置 ipam 相关参数 ipamhandles 用于保存 pod 与 block 关系 ippool 表示 IP 地址的集合，Calico 从中分配 IP给 pod。 示例 yaml：</description></item><item><title>calico 安装</title><link>https://www.ryken.cloud/calico-%E5%AE%89%E8%A3%85/</link><pubDate>Sat, 27 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/calico-%E5%AE%89%E8%A3%85/</guid><description>manifests 安装 upgrade-ipam 用于升级 Calico CNI 插件的 IPAM 管理模块，以支持更高效和灵活的 IP 地址池的管理。 install-cni 安装 calico-cni 到指定目录 flexvol-driver 容器存储接口（CSI）驱动程序 在每个pod中运行的Felix和Dikastes容器之间启用安全连接。它挂载了一个共享卷，Felix将Unix域套接字插入其中 Dikastes是一个容器，它与Calico的Felix组件一起运行，用于在每个pod中实现应用层策略。它通过与Felix共享的Unix域套接字与Felix进行通信，以便在Envoy代理中执行Calico安全策略 https://www.</description></item><item><title>3. OFN QuickStart</title><link>https://www.ryken.cloud/3.-OFN-QuickStart/</link><pubDate>Thu, 25 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/3.-OFN-QuickStart/</guid><description>环境要求 镜像仓库 secret 构建 funcation 会构建一个 funcation 镜像，此时需要你将构造的镜像 push 到 dockerhub 或者Quary.io 因此需要提供一个 secret
1 2 3 4 5 REGISTRY_SERVER=https://index.</description></item><item><title>About me</title><link>https://www.ryken.cloud/About-me/</link><pubDate>Wed, 24 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/About-me/</guid><description> My Github MyKnowledgeGarden (ryken.cloud) MyEmail: rykren1998@gmail</description></item><item><title>搭建数字花园</title><link>https://www.ryken.cloud/%E6%90%AD%E5%BB%BA%E6%95%B0%E5%AD%97%E8%8A%B1%E5%9B%AD/</link><pubDate>Wed, 24 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E6%90%AD%E5%BB%BA%E6%95%B0%E5%AD%97%E8%8A%B1%E5%9B%AD/</guid><description>发布的方案： obsidian 目前最完美的免费发布方案 - 渐进式教程 (oldwinter.top)
参考发布的花园 + 搭建方案：
quartz + obsidian-export(添加.export-ignore)+github jackyzha0/quartz: 🌱 host your own second brain and digital garden for free (github.</description></item><item><title>数字花园来历</title><link>https://www.ryken.cloud/%E6%95%B0%E5%AD%97%E8%8A%B1%E5%9B%AD%E6%9D%A5%E5%8E%86/</link><pubDate>Wed, 24 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E6%95%B0%E5%AD%97%E8%8A%B1%E5%9B%AD%E6%9D%A5%E5%8E%86/</guid><description>仅为个人看法，不喜勿喷，谢谢！！！若有侵犯到你，纯属偶然，请联系我删除。
看了这篇 《语雀困住了多少人》有感，来讲讲我和语雀的交集。
之前我一直使用的笔记软件是OneNote，它的功能非常强大，一块画布可以无限放大，支持图片、文件、绘图、录音等各种内容的插入。但是同步和共享方面存在一些问题，速度也比较慢。后来了解到了语雀，并逐步将笔记增量记录到语雀上(不得不说语雀的知识库管理还是可以的)。直到2022年10月份左右，语雀推出了一个付费计划。当笔记数量超过100篇时就需要收费。当时有很多用户的笔记数量已经超过了这个数字，也不得不说语雀这波调整吃相难看。过了一段时间，语雀重新调整了收费标准，普通用户一个月可以创建100篇文章，知识库上限是10篇，且不能公开共享知识库。刚开始会通过一些活动免费赠送3个月或6个月的会员资格，等用户逐渐接受后开始正常收费来购买会员了。
语雀个人定价调整的致歉 语雀个人版新定价的细则和思考 不过在他第一次调整收费标准的时候，我就已经下定决心换用其他的软件了，因为我之前不知道从哪里了解到语雀会开源，但是语雀的行动告诉我他要收费了，这个落差有点大。⊙_⊙ 算了算了
确实公司也是要吃饭的，但是我还是喜欢白嫖，如于是乎就开始找一些容错率高、方便迁移、方便共享、风格类似的笔记软件以及发布平台。
其实我一直想搭建一个属于自己的笔记库，而不是博客那种形式。相较于博客检索不太方便，我更倾向于使用笔记库或数字花园来记录和管理笔记，因为它采用正反链的关系图、发散的方式进行管理。这种关系图更能符合我当初记录笔记时的初衷。并且在发布很久之后回头查看，可以很快地找到当初的那种感觉。另外笔记库也可以使用文件夹的方式来管理文档(类似归档)，使用 tag 进行分类。
对于数字花园，你可以去以下链接中了解更多信息：</description></item><item><title>语雀导出文档小工具</title><link>https://www.ryken.cloud/%E8%AF%AD%E9%9B%80%E5%AF%BC%E5%87%BA%E5%B0%8F%E5%B7%A5%E5%85%B7/</link><pubDate>Wed, 24 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E8%AF%AD%E9%9B%80%E5%AF%BC%E5%87%BA%E5%B0%8F%E5%B7%A5%E5%85%B7/</guid><description>语雀导出文档小工具 功能： 模拟用户浏览器操作一篇一篇导出 markdown 文档 支持将同名的文档导出 支持导出失败重试 我的知识库与导出文件目录 说明： 这是一个基于puppeteer 来模拟用户在浏览器的操作一篇一篇的导出语雀文档的工具。 关于语雀的导出可以详情说明见官方的文档： 如何导入导出知识库
首先语雀支持导出文档为 markdown 格式。 单篇导出：支持导出为 markdown、word、pdf、lakebook等 批量导出：支持导出为 lakebook、pdf 格式。对于超级用户是可以通过创建 token 来使用 官方的 exporter 工具或者其他基于 api 的工具进行批量导出；超级用户的价格为 299/月。</description></item><item><title>multipass</title><link>https://www.ryken.cloud/multipass/</link><pubDate>Tue, 23 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/multipass/</guid><description>官方github： https://github.com/canonical/multipass windows 环境下的安装以及使用： https://multipass.run/docs/installing-on-windows
windows 支持以下两种模式：
Hyper-V：（只能是windows Pro 或者 windows 企业版） VirtualBox：依赖 VirtualBox 切换模式：
multipass set local.</description></item><item><title>calico 应急方案</title><link>https://www.ryken.cloud/calico-%E5%BA%94%E6%80%A5%E6%96%B9%E6%A1%88/</link><pubDate>Wed, 10 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/calico-%E5%BA%94%E6%80%A5%E6%96%B9%E6%A1%88/</guid><description>确认出现问题的具体部分和错误现象 确认问题出现的时间、场景，了解系统的运行环境、版本信息、系统配置等，以便明确问题的范围和分析。 确认错误现象是否具有可重现性，是否存在规律性与周期性，有助于问题进一步排查和分析。 检查 Calico 日志[[CloudNative/cni-network/calico/日志/日志|日志]] 查看 calico describe 以及日志。[[通过事件、日志排查]] 根据错误提示或警告信息，查找相关的解决方案或错误排除方法。 如果日志中没有明显错误或警告信息，可以将日志级别调整为 DEBUG，查看更为详细的日志信息，进一步分析问题原因。 calico没有明显错误日志记录时，可以查看系统日志，并参考系统资源情况来分析问题原因。[[根据系统日志排查]] 进行网络诊断 [[网络工具诊断]] 使用 ping、traceroute、tcpdump 等网络诊断工具，检查网络连通性和网络通信状态(pod-pod/pod-node/pod-svc/node-svc/node-gateway、pod-gateway)，确认是否存在网络问题，并从 gateway→node→svc→pod 一层一层更细化的定位问题根源。 如果问题根源涉及 pod，可以从 ipam、bgp 路由角度分析 如果涉及 svc，可以从 kube-proxy、iptables 角度分析 如果涉及 node，可以从物理网络、gateway 角度分析 对比不同机器上的性能指标以及网络状况，确定出错的机器是否存在特殊网络问题。 检查 Calico 配置 [[calico配置文件]] 确认 Calico 的配置文件是否正确，是否缺失或错误配置。包括 cni configmap、bgp、bgppeer、felix等相关配置 检查系统资源使用情况 查看系统 CPU、内存、磁盘等资源的使用情况，如果存在资源不足或超载现象，可以考虑优化或扩容。 确认 Calico 的网络带宽使用情况，分析网络流量的分布和情况，确认是否出现了网络流量瓶颈。 逐一排查可能的原因 如果是网络通信问题，可以检查网络拓扑，路由器、交换机、防火墙等设备的配置，确认是否存在配置错误或故障。 如果是性能瓶颈问题，可以进行性能测试和优化，如使用性能工具、调整配置参数等。 如果是系统崩溃问题，可以通过故障日志、内存转储文件等进行分析定位。 进行测试环境部署和测试 如果出现问题的环境比较复杂，可以考虑在测试环境中进行部署和测试，以排除环境配置和部署工具问题。 更新和升级 Calico 版本 如果发现 Calico 的问题存在于旧版本中，可以尝试升级到最新版本。 Upgrade Calico on Kubernetes 寻求社区帮助 如果以上方法无法解决问题，可以联系 Calico 的社区成员，提供详细的问题描述和相关信息，以便社区成员进行协助和解决。 可以在社区论坛或邮件列表上留言，或直接向社区成员联系，提供相关问题信息，交流问题解决方案。 Issues · projectcalico/calico Discuss Calico https://calicousers.</description></item><item><title>日志</title><link>https://www.ryken.cloud/%E6%97%A5%E5%BF%97/</link><pubDate>Wed, 10 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E6%97%A5%E5%BF%97/</guid><description>calico 日志 calico 主要运行组件为：calico-node 以及 calico-kube-controller-manager
calico-node 主要有 felix、bird、cni 对于 kube-controller-manager 日志没有特殊配置 node 实例的日志： kubectl logs -n kube-system calico-node-xxxx</description></item><item><title>网卡 vlan</title><link>https://www.ryken.cloud/%E7%BD%91%E5%8D%A1-vlan/</link><pubDate>Wed, 10 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E7%BD%91%E5%8D%A1-vlan/</guid><description>添加 vlan 子接口 使用 ip 命令 ip link add link enp125s0f0 name enp125s0f0.100 type vlan id 100 使用 vconfig 命令 相关模块 lsmod |grep -i 8021q 相关工具包 apt-get install vlan or yum install vconfig modprobe 8021q 添加 vlan vconfig add enp8s0f1 100 在enp8s0f1接口上配置两个VLAN vconfig set_flag enp8s0f1.</description></item><item><title/><link>https://www.ryken.cloud/2.-%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/2.-%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5/</guid><description>预编译、编译、汇编、链接
1 2 3 4 5 6 7 // hello.c #include &amp;lt;stdio.h&amp;gt;int main() { printf(&amp;#34;hello world\n&amp;#34;); return 0; } | $ gcc hello.</description></item><item><title/><link>https://www.ryken.cloud/3.-%E5%B7%A5%E5%85%B7%E9%93%BE/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/3.-%E5%B7%A5%E5%85%B7%E9%93%BE/</guid><description>安装
工具 go build
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 usage: go build [-o output] [build flags] [packages] # 根据他们的依赖来编译import路径中的包，但是不install结果 Build compiles the packages named by the import paths, along with their dependencies, but it does not install the results.</description></item><item><title/><link>https://www.ryken.cloud/3.-%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/3.-%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6/</guid><description>编译器编译源码之后的生成的文件叫做目标文件
2. 3. ELF文件结构描述 文件头 段表 重定位表 字符串表 4. 链接的接口 - 符号</description></item><item><title/><link>https://www.ryken.cloud/3.1-%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E7%9A%84%E6%A0%BC%E5%BC%8F/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/3.1-%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E7%9A%84%E6%A0%BC%E5%BC%8F/</guid><description>目标文件的格式 现在PC平台流行的可执行文件格式只要是PE(Windows Portable Executable)和ELF(Linux Executable Linkable Format)。它们都是COFF(Common file format)的变种。COFF的主要贡献是在目标文件中引入了段的机制，不同的目标文件可以拥有不同数量以及不同类型的段，另外还定义了调试数据格式。目标文件就是源代码编译之后没有进行链接的中间文件，它同可执行文件的内容结构很相似，所以一般与可执行文件一起采用一种格式存储。 不光可执行文件按照可执行文件格式存储，动态链接库以及静态链接库都是按照可执行文件的格式进行存储，Windows下统称为PE-COFF文件格式，Linux下统称为ELF文件。 静态链接库稍有不同，静态链接库把很多目标文件捆绑在一起形成一个文件，再加上一些索引。我们可以把它理解为一个包含很多目标文件的文件包。 ELF文件标准将系统中ELF格式的文件归为以下4类：
ELF文件类型 说明 实例 可重定向文件【Relocatable File】 这类文件包含了代码和数据，可以被用来连链接成可执行文件或共享目标文件，静态链接库也可以归为这一类 Linux的.</description></item><item><title/><link>https://www.ryken.cloud/3.2-%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E7%9A%84%E5%86%85%E5%AE%B9/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/3.2-%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E7%9A%84%E5%86%85%E5%AE%B9/</guid><description>目标文件的内容 目标文件中含有编译后的机器指令代码、数据以及链接时所需要的一些信息，比如符号表、调试信息、字符串等。一般目标文件将这些信息按照不同的属性，以“节/段”的形式存储。
段名 名称 内容 代码段 .code或者.text 源代码编译后的机器指令 数据段 .data 全局变量和局部静态变量 .</description></item><item><title/><link>https://www.ryken.cloud/3.3-ELF%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E6%8F%8F%E8%BF%B0/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/3.3-ELF%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E6%8F%8F%E8%BF%B0/</guid><description>ELF基本结构 ELF文件头：包含了描述整个文件的基本属性(ELF文件版本、目标机器型号、程序入口地址等) 各个段（代码段、数据段、bss段） 段表：描述了ELF文件包含的所有段的信息(段名、段的长度、在文件中的偏移、读写权限、段的其他属性) ELF辅助结构：字符串表、符号表等 文件头 readelf 命令查看ELF文件：readelf -h hello.o
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ELF Header | ELF Header: ELF魔数 | Magic: 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 文件机器字节长度 | Class: ELF64 数据存储方式 | Data: 2&amp;#39;s complement, little endian 版本 | Version: 1 (current) 运行平台 | OS/ABI: UNIX - System V ABI版本 | ABI Version: 0 ELF重定位类型 | Type: REL (Relocatable file) 硬件平台 | Machine: Advanced Micro Devices X86-64 硬件平台版本 | Version: 0x1 入口地址 | Entry point address: 0x0 程序头入口 | Start of program headers: 0 (bytes into file) 段表的位置 | Start of section headers: 1176 (bytes into file) ———— | Flags: 0x0 文件头长度 | Size of this header: 64 (bytes) 程序头长度 | Size of program headers: 0 (bytes) 程序头数量 | Number of program headers: 0 段表的长度 | Size of section headers: 64 (bytes) 段数量 | Number of section headers: 14 | Section header string table index: 13 ELF文件头中定义了ELF魔数、文件机器字节长度、数据存储方式、版本、运行平台、ABI版本、ELF重定位类型、硬件平台、硬件平台版本、入口地址、程序头入口和长度、段表的位置和长度、段的数量等。 ELF魔数：16个字节，用于标识ELF文件的平台属性。如ELF字长、字节序、ELF文件版本。 ELF文件的魔数：7f 45 4c 46；a.</description></item><item><title/><link>https://www.ryken.cloud/3.4-%E9%93%BE%E6%8E%A5%E7%9A%84%E6%8E%A5%E5%8F%A3-%E7%AC%A6%E5%8F%B7/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/3.4-%E9%93%BE%E6%8E%A5%E7%9A%84%E6%8E%A5%E5%8F%A3-%E7%AC%A6%E5%8F%B7/</guid><description>链接的本质就是将不同的目标文件之间相互粘在一起，想要粘合就必须要有固定的规则才行。在链接中，目标文件之间相互拼合实际上是目标文件之间对地址的引用，即对函数和变量的地址的引用，如A使用B中的函数func，即A中定义了函数func、B引用了func。链接中，我们将函数和变量统称为改符号，函数名或者变量名就是符号名。 整个链接的过程正是基于符号才能正确完成，链接的过程中很关键的一部分就是符号的管理，每一个目标文件都会有一个相应的符号表，这个表里面记录目标文件中所用到的所有符号，每个定义的符号有一个对应的值叫做符号值。对于变量核函数来说，符号值就是它们的地址，我们将符号表中的所有符号进行分类：
定义在本目标文件的全局符号，可以被其他目标文件引用 在本目标文件中引用的全局符号，却没有定义在本目标文件，这一般叫外部符号。 段名，这种符号往往由编译器产生，它的值就是该段的起始地址 局部符号，这类符号往往只在编译单元内部可见，比如static的变量。调试器可以使用这些符号来分析程序或奔溃时的核心转储文件。这些局部符号对于链接过程没有作用，链接器往往会忽略它们 行号信息，即目标文件指令与源代码中代码行的对应关系，这是可选的 我们最关心的是全局符号，即以上分类的第一类和第二类，因为链接的过程只关心全局符号的相互粘合，局部符号、段名、行号等都是次要的，因为他们对于其他目标文件来说是不可见的。 查看符号表命令：nm hello.o
1 2 3 4 5 6 7 8 9 root@orange:/home/orange/program/test# nm hello.</description></item><item><title/><link>https://www.ryken.cloud/4.-%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/4.-%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5/</guid><description>本章小结：</description></item><item><title/><link>https://www.ryken.cloud/9.1-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/9.1-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</guid><description>单元测试/性能测试/代码覆盖率等一起保障了代码总是在可控范围内。单元测试用来测试包或者程序的一部分代码或者一组代码的函数。
单元测试分类
正向测试：在正常执行的情况下，保证代码不产生错误的测试。
反向测试：保证代码不仅会产生错误，而且是预期的错误
基础测定：只使用一组参数和结果来测试一段代码
表组测试：使用多组参数和结果来进行测试
mock测试：模仿测试代码需要用到的外部资源，比如：数据库或网络服务器，有助于让测试在没有所需要的外部资源可用的时候，模拟这些资源的行为使得测试正常进行。
testing 工具链和标准库自带的单元测试框架，可以使测试工作变得相对容易，提供了从测试框架到报告测试的输出和状态的各种测试功能的支持。</description></item><item><title/><link>https://www.ryken.cloud/9.2-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/9.2-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/</guid><description>性能测试函数以benchmark为前缀，同样保存在&amp;quot;*_test.go&amp;quot;文件中 go test -bench. 测试工具默认不会执行性能测试，须使用bench参数，他逐步调整B.N值，反复执行测试函数，直到能获得准确的测试结果。
如果希望只执行性能测试，run=NONE忽略所有的单元测试用例。 默认以并发方式执行测试，但可用cpu参数设定多个并发限制来观察结果。 benchtime用于设定最小测试时间，增加循环次数，用于解决某些耗时的目标默认循环次数过少，取平均值不足以精确计量性能。
timer 如果在测试函数中要执行一些额外的操作，应该临时停止定时器工作
memory 性能测试关心的不仅仅是执行时间，还包括在堆上的内存分配。内存分配和内存回收的相关操作也应计入到消耗成本 go test -bench . -benchmem -gcflags &amp;ldquo;-N -l&amp;rdquo; # 禁用内联和优化，便于观察结果 可以将测试函数设置为总输出内存分配信息，无论是否使用benchmem参数 B.</description></item><item><title/><link>https://www.ryken.cloud/9.3-%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/9.3-%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87/</guid><description>单元测试与性能测试关注代码质量，代码覆盖率度量测试自身完整和有效性的一种手段 通过覆盖值，可以分析出测试代码的编写质量；检测其是否提供了足够的测试条件，是否执行了足够的函数/语句/分支/代码行，以此量化测试本身，让白盒测试起到应有的质量保证。 代码覆盖率也常被用来发现死代码（永远不会被执行的代码）
1 2 3 4 5 6 7 8 9 10 11 12 13 14 func deadCode(a,b int) { num := a+b if num &amp;gt; 3 { log.</description></item><item><title/><link>https://www.ryken.cloud/9.4-%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/9.4-%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/</guid><description>引发性能问题：执行时间过长/内存占用过多/意外阻塞 等 通过捕获监控相关执行状态数据，便可定位引发问题的原因，从而优化改进。
在测试时输出并保存相关数据，进行初期评估 在运行阶段通过web接口获取实时数据，分析一段时间内的健康状况 除此之外，可以使用自定义计数器（expvar）提供更多与逻辑相关的参考数据 go test -run -bench . -memprofile mem.out -cpuprofile cpu.out net/http</description></item><item><title/><link>https://www.ryken.cloud/c++%E7%B1%BB%E5%B0%81%E8%A3%85/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/c++%E7%B1%BB%E5%B0%81%E8%A3%85/</guid><description>CGO是C语言和Go语言之间的桥梁，原则上无法直接支持C++的类。CGO不支持C++语法的根本原因是C++至今为止还没有一个二进制接口规范(ABI)。一个C++类的构造函数在编译为目标文件时如何生成链接符号名称、方法在不同平台甚至是C++的不同版本之间都是不一样的。但是C++是兼容C语言，所以我们可以通过增加一组C语言函数接口作为C++类和CGO之间的桥梁，这样就可以间接地实现C++和Go之间的互联。当然，因为CGO只支持C语言中值类型的数据类型，所以我们是无法直接使用C++的引用参数等特性的。
c++类到Go语言对象 【声明接口】先从用户的角度思考需要什么样的接口，提供一个纯c语言的接口 【纯C实现接口】基于C++的类定义这些C语言包装函数，并用纯c函数接口封装C++类 【将纯C接口转为Go函数】如果包中有C++11的语法，要通过#cgo CXXFLAGS: -std=c++11打开C++11 【进一步将Go函数封装为Go对象】基于GO函数封装为Go语法的Go对象 Go语言对象到C++类 【声明接口】先从用户的角度思考需要什么样的接口，提供一个纯c语言的接口 【导出C接口】基于Go语言封装Go对象，导出C接口 【封装C++对象】有了C接口，进一步进行C++的封装为对象 将Go对象导出为C接口，然后基于C接口再包装为C++对象以便于使用</description></item><item><title/><link>https://www.ryken.cloud/CGO%E5%85%A5%E9%97%A8/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/CGO%E5%85%A5%E9%97%A8/</guid><description>使用系统库输出helloworld 1 2 3 4 5 6 7 8 package main //#include &amp;lt;stdio.h&amp;gt; import &amp;#34;C&amp;#34; func main() { C.</description></item><item><title/><link>https://www.ryken.cloud/CGO%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/CGO%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</guid><description>CGO是架接Go语言和C语言的桥梁，它使二者在二进制接口层面实现了互通，但是我们要注意因两种语言的内存模型的差异而可能引起的问题。如果在CGO处理的跨语言函数调用时涉及到了指针的传递，则可能会出现Go语言和C语言共享某一段内存的场景。我们知道C语言的内存在分配之后就是稳定的，但是Go语言因为函数栈的动态伸缩可能导致栈中内存地址的移动(这是Go和C内存模型的最大差异)。如果C语言持有的是移动之前的Go指针，那么以旧指针访问Go对象时会导致程序崩溃。
GO访问C内存 C语言空间的内存是稳定的，只要不是被人为提前释放，那么在Go语言空间可以放心大胆地使用。 因为Go语言实现的限制，我们无法在Go语言中创建大于2GB内存的切片（具体请参考makeslice实现代码）。不过借助cgo技术，我们可以在C语言环境创建大于2GB的内存，然后转为Go语言的切片使用：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main /* #include &amp;lt;stdlib.</description></item><item><title/><link>https://www.ryken.cloud/CGO%E7%BC%96%E7%A8%8B/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/CGO%E7%BC%96%E7%A8%8B/</guid><description>笔记来源： https://www.cntofu.com/book/73/ch2-cgo/readme.md Go语言函数调用C语言函数以复用C语言资源这一目的而出现的（因为C语言还会涉及回调函数，自然也会涉及到从C语言函数调用Go语言函数）。 要使用CGO特性，需要安装C／C构建工具链，在macOS和Linux下是要安装和GCC，在windows下是需要安装MinGW工具。同时需要保证环境变量CGO_ENABLED被设置为1，这表示CGO是被启用的状态。在本地构建时CGO_ENABLED默认是启用的，当交叉构建时CGO默认是禁止的。
通过import &amp;quot;C&amp;quot;语句启用CGO特性。紧跟在这行语句前面的注释是一种特殊语法，里面包含的是正常的C语言代码。当确保CGO启用的情况下，还可以在当前目录中包含C/C++对应的源文件。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main /* #include &amp;lt;stdio.</description></item><item><title/><link>https://www.ryken.cloud/dlv-%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/dlv-%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85/</guid><description>dlv官网： https://github.com/derekparker/delve 下载安装详看： https://github.com/derekparker/delve/blob/master/Documentation/installation/linux/install.md 官方安装文档介绍 **Installation on Linux，**有两种方法在linux上安装dlv。 第一种使用go get：
| export GOPROXY=https://goproxy.cn
go get github.</description></item><item><title/><link>https://www.ryken.cloud/dlv-%E8%B0%83%E8%AF%95core%E6%96%87%E4%BB%B6/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/dlv-%E8%B0%83%E8%AF%95core%E6%96%87%E4%BB%B6/</guid><description>linux环境下 生成core文件 设置环境变量 export GOTRACEBACK=crash 解除ulimit系统资源限制，允许生成core文件 有关GOTRACEBACK参考官网： https://pkg.go.dev/runtime?utm_source=godoc 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;time&amp;#34; ) func main() { waitchan := make(chan struct{}) go func() { for i := 0; i &amp;lt; 10; i++ { fmt.</description></item><item><title/><link>https://www.ryken.cloud/dlv-%E8%B0%83%E8%AF%95%E4%BD%BF%E7%94%A8/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/dlv-%E8%B0%83%E8%AF%95%E4%BD%BF%E7%94%A8/</guid><description>工程目录如下： | ├── github.com/me/foo ├── cmd │ └── foo │ └── main.go ├── pkg │ └── baz │ ├── bar.go</description></item><item><title/><link>https://www.ryken.cloud/gdb%E8%B0%83%E8%AF%95go%E4%BB%A3%E7%A0%81/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/gdb%E8%B0%83%E8%AF%95go%E4%BB%A3%E7%A0%81/</guid><description>官方使用gdb：Debugging Go Code with GDB https://golang.org/doc/gdb
linux 下载安装gdb apt-get install gdb
gdb调试go代码时，gdb版本要≥7.5 同时禁用编译器的优化使得方便调试：go build -gcflags=all=&amp;quot;-N -l&amp;quot;
gdb调试常用命令 r：run，执行程序</description></item><item><title/><link>https://www.ryken.cloud/go-context/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/go-context/</guid><description>context控制调用函数的超时返回
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 func main() { .</description></item><item><title/><link>https://www.ryken.cloud/go-Convey%E6%B5%8B%E8%AF%95/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/go-Convey%E6%B5%8B%E8%AF%95/</guid><description>go convey在开启了一个协程，并在其中进行断言，触发panic
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 //panic: Convey operation made without context on goroutine stack.</description></item><item><title/><link>https://www.ryken.cloud/go-defer/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/go-defer/</guid><description>defer应用场景 GO defer会在当前函数返回前执行传入的函数，经常被用于关闭文件描述符、关闭数据库连接以及解锁资源，在函数调用结束后完成一些收尾工作。
常见问题：
defer 关键字的调用时机以及多次调用 defer 时执行顺序是如何确定的； defer 关键字使用传值的方式传递参数时会进行预计算，导致不符合预期的结果； 1. 执行顺序 1 2 3 4 5 6 7 8 9 10 11 12 func defer_call() { defer func() { fmt.</description></item><item><title/><link>https://www.ryken.cloud/go-mock-%E6%B5%8B%E8%AF%95/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/go-mock-%E6%B5%8B%E8%AF%95/</guid><description>1 2 3 4 === RUN Testxxx Testxxx: box_test.go:239: missing call(s) to *xxxmock.Mockxxx.xxx(is anything, is anything, is anything) xxx/xxx/xxx/box_test.go:202 Testxxx: box_test.</description></item><item><title/><link>https://www.ryken.cloud/go-newmake/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/go-newmake/</guid><description>Go语言中new和make是内建的两个函数，主要用来分配内存。 在Go语言中对于值类型的声明不需要分配内存空间，是因为它们在声明的时候已经默认分配好了内存空间。而对于引用类型的变量，我们在使用的时候不仅要声明它，还要为它分配内存空间，否则我们的值就没办法存储。
new 根据传入的类型分配一片内存空间并返回指向这片内存空间的指针。使用new函数得到的是一个类型的指针，并且该指针对应的值为该类型的零值。new的函数签名如下：
1 func new(Type) *Type make make也是用于内存分配的，区别于new，它只用于slice、map以及chan的内存创建。我们在代码中往往都会使用如下所示的语句初始化这三类基本类型，这三个语句分别返回了不同类型的数据结构：
1 2 3 4 5 6 7 8 slice := make([]int, 0, 100) hash := make(map[int]bool, 10) hash := make(map[int]bool) ch := make(chan int, 5) // slice 是一个包含 data、cap 和 len 的结构体 reflect.</description></item><item><title/><link>https://www.ryken.cloud/go-%E6%89%93%E5%8C%85%E5%92%8C%E5%B7%A5%E5%85%B7%E9%93%BE/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/go-%E6%89%93%E5%8C%85%E5%92%8C%E5%B7%A5%E5%85%B7%E9%93%BE/</guid><description>go mod
1 2 3 4 5 6 7 8 9 10 verifying git.ghostcloud.cn/newben/log@v0.0.2: checksum mismatch downloaded: h1:5bclc0fb8Q3FSzheOP1AhqYNSDvZu4i7021j5YEa3zQ= go.sum: h1:FUGx1ZtSCxsGW/BzbMrGp9XN6eKkigN3J4i1q5kughc= SECURITY ERROR This download does NOT match an earlier download recorded in go.</description></item><item><title/><link>https://www.ryken.cloud/Go-%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/Go-%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/</guid><description>init函数先于main函数运行 编译器检测Client是否实现了io.Closer interface所定义的函数 1 var _ io.Closer = (*Client)(nil) go处理超时：使用 time.After() 结合 select+chan 完成。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // called 管道用于超时处理，send管道用于阻塞等待sendResponse func (server *Server) handleRequest(cc codec.</description></item><item><title/><link>https://www.ryken.cloud/GoAccess-%E5%8F%AF%E8%A7%86%E5%8C%96%E7%9B%91%E6%8E%A7access%E6%97%A5%E5%BF%97/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/GoAccess-%E5%8F%AF%E8%A7%86%E5%8C%96%E7%9B%91%E6%8E%A7access%E6%97%A5%E5%BF%97/</guid><description>下载安装： https://goaccess.io/download 快速开始： https://goaccess.io/get-started
在上游服务的nginx中添加 :
1 2 3 4 access_log logs/renyunkang-test.access.log main; location /report.html { alias /usr/local/openresty/nginx/html/report.html; } goaccess /usr/local/openresty/nginx/logs/renyunkang-test.</description></item><item><title/><link>https://www.ryken.cloud/golang-%E6%B5%8B%E8%AF%95/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/golang-%E6%B5%8B%E8%AF%95/</guid><description>go test -v -run 测试函数名字
Go Test 单元测试简明教程 Go Mock (gomock)简明教程链接 go测试工具goconvey的使用 GoConvey测试框架使用指南 goconvey - 课时 1：优雅的单元测试</description></item><item><title/><link>https://www.ryken.cloud/golang-%E7%AE%A1%E9%81%93/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/golang-%E7%AE%A1%E9%81%93/</guid><description>golang 管道的设计原因
阻塞 同步、通信 先进先出 管道用于进程间通信 &amp;ndash; 同步、利用阻塞读写 &amp;ndash; 类似与WaitGroup的同步示例 管道实现的生产者、消费者模型 注意事项：管道关闭 通信 协程是并发编程的基础，而管道是并发中协程之间沟通的桥梁，很多时候我们启动一个协程去执行完一个操作，执行操作之后我们需要返回结果，或者多个协程之间需要相互协作，先看一个例子：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;sync&amp;#34; ) var wg = sync.</description></item><item><title/><link>https://www.ryken.cloud/golang-%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/golang-%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/</guid><description>总览 File → Settings → Build,Execution… → Deployment 添加自己的远程主机的地址，以及Mapping代码上传到远程的存放目录 在工程名按下快捷键ctrl+alt+shrift+x，将代码上传到远程 在下方终端中ssh到终端，编译 进入编译出二进制路径，开始dlv调试 dlv &amp;ndash;listen=:2345 &amp;ndash;headless=true &amp;ndash;api-version=2 exec .</description></item><item><title/><link>https://www.ryken.cloud/golang%E5%85%B6%E4%BB%96%E7%9B%B8%E5%85%B3%E5%BA%93/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/golang%E5%85%B6%E4%BB%96%E7%9B%B8%E5%85%B3%E5%BA%93/</guid><description>go-ping:
https://github.com/go-ping/ping https://www.cnblogs.com/wlw-x/p/14169607.html</description></item><item><title/><link>https://www.ryken.cloud/golang%E5%9F%BA%E7%A1%80/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/golang%E5%9F%BA%E7%A1%80/</guid><description>reflect 反射 - 获取某个结构体的所有方法 通过反射实现结构体与服务的映射关系
interface与reflect
interface
类型转换 https://books.studygolang.com/advanced-go-programming-book/ch2-cgo/ch2-03-cgo-types.html
Go解决现代编程难题 快速的开发/编译速度 内置并发机制，无须特定的线程库 类型系统简单高效，专注代码复用 自带垃圾回收器，无须自己管理内存 go 包管理</description></item><item><title/><link>https://www.ryken.cloud/golang%E6%A0%87%E5%87%86%E5%BA%93/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/golang%E6%A0%87%E5%87%86%E5%BA%93/</guid><description>Packages ： https://golang.org/pkg/</description></item><item><title/><link>https://www.ryken.cloud/https%E7%9B%B8%E5%85%B3%E5%AE%89%E5%85%A8%E6%80%A7/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/https%E7%9B%B8%E5%85%B3%E5%AE%89%E5%85%A8%E6%80%A7/</guid><description>验证证书的颁发证书者是不是有效的 证书类型
域名验证 domain validated DV证书 组织验证 organization validated OV证书 扩展验证 extend validated EV证书 安装certbot apt-get install -y python3-certbot-nginx</description></item><item><title/><link>https://www.ryken.cloud/http%E8%AF%B7%E6%B1%82/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/http%E8%AF%B7%E6%B1%82/</guid><description>http post body请求 1 2 3 4 5 6 7 ### POST http://10.0.2.179:81/apis/license/update Accept: application/json Authorization: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2MjQ1Mjc3MTAsImlhdCI6MTYyNDUxNjkxMCwiaXNzIjoiY29yZXNlcnZlciIsInN1YiI6ImFkbWluIn0.yJs1iwR9NwFg2PLEKFv6WygiLTuU4xhLA3ne7mVuVOM Content-Type: application/json; charset=utf-8; {&amp;#34;license&amp;#34;:&amp;#34;AWFiY2RlZnAAshsmL9Ef9yuqW&amp;#34;} http get url请求 1 2 3 4 ### GET http://10.</description></item><item><title/><link>https://www.ryken.cloud/kubernetes%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%9C%AF%E8%AF%AD/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/kubernetes%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%9C%AF%E8%AF%AD/</guid><description>Kubernetes中的大部分概念如Node、Pod、Replication Controller、Service等都可以被看作一种资源对象，几乎所有资源对象都可以通过kubectl工具（或者API编程调用）执行增、删、改、查等操作并将其保存在etcd中持久化存储。从个角度来看，Kubernetes其实是一个高度自动化的资源控制系统，它通过跟踪对比etcd库里保存的“资源期望状态”与当前环境中的“实际资源状态”的差异来实现自动控制和自动纠错的高级功能。 声明资源时的一个关键属性：apiVersion。 Kubernetes平台采用了“核心+外围扩展”的设计思路，在保持平台核心稳定的同时具备持续演进升级的优势。Kubernetes大部分常见的核心资源对象都归属于v1这个核心API，比如Node、Pod、Service、Endpoints、Namespace、RC、PersistentVolume等。在版本迭代过程中，Kubernetes先后扩展了extensions/v1beta1、apps/v1beta1、apps/v1beta2等API组，而在1.9版本之后引入了apps/v1这个正式的扩展API组，正式淘汰（deprecated）了extensions/v1beta1、apps/v1beta1、apps/v1beta2这三个API组。</description></item><item><title/><link>https://www.ryken.cloud/map%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/map%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</guid><description>go map的底层机制 操作go map时需要注意什么 map有两种取元素的方法
1 2 value := my_map[&amp;#34;key&amp;#34;] value,exists := my_map[&amp;#34;key&amp;#34;] map的键可以是任何相等性操作符支持的类型， 如整数、浮点数、复数、字符串、指针、接口（只要其动态类型支持相等性判断）、结构以及数组。
无法对 map 的 key 或 value 进行取址 map中的元素并不是一个变量，而是一个值。因此，我们不能对map的元素进行取址操作，不能直接进行修改。 修改map中对应value的值时，若value对应的类型不是指针时，不能直接进行修改，需要取一个临时变量进行赋值或者修改为指针类型</description></item><item><title/><link>https://www.ryken.cloud/MasterNode/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/MasterNode/</guid><description>Master Kubernetes里的Master指的是集群控制节点，在每个Kubernetes集群里都需要有一个Master来负责整个集群的管理和控制，基本上Kubernetes的所有控制命令都发给它，它负责具体的执行过程，我们后面执行的所有命令基本都是在Master上运行的。Master通常会占据一个独立的服务器。
在Master上运行着以下关键进程：
Kubernetes API Server（kube-apiserver）：提供了HTTP Rest接口的关键服务进程，是Kubernetes里所有资源的增、删、改、查等操作的唯一入口，也是集群控制的入口进程。 Kubernetes Controller Manager（kube-controller-manager）：Kubernetes里所有资源对象的自动化控制中心，可以将其理解为资源对象的“大总管”。 Kubernetes Scheduler（kube-scheduler）：负责资源调度（Pod调度）的进程，相当于公交公司的“调度室”。 另外，在Master上通常还需要部署etcd服务，因为Kubernetes里的所有资源对象的数据都被保存在etcd中。
Node Node是Kubernetes集群中的工作负载节点，每个Node都会被Master分配一些工作负载（Docker容器），当某个Node宕机时，其上的工作负载会被Master自动转移到其他节点上。 在每个Node上都运行着以下关键进程。
kubelet：负责Pod对应容器创建、启停等任务，同时与Master密切协作，实现集群管理的基本功能。 kube-proxy：实现Kubernetes Service的通信与负载均衡机制的重要组件。 Docker Engine（docker）：Docker引擎，负责本机的容器创建和管理工作。 Node可以在运行期间动态增加到Kubernetes集群中，在默认情况下kubelet会向Master注册自己，这也是Kubernetes推荐的Node管理方式。一旦Node被纳入集群管理范围，kubelet进程就会定时向Master汇报自身信息，例如操作系统、Docker版本、机器的CPU和内存情况，以及当前有哪些Pod在运行等，这样Master就可以获知每个Node的资源使用情况，并实现高效均衡的资源调度策略。而某个Node在超过指定时间不上报信息时，会被Master判定为“失联”，Node的状态被标记为不可用（Not Ready），随后Master会触发“工作负载大转移”的自动流程。 kubectl describe node node_name 查看某个node的信息。</description></item><item><title/><link>https://www.ryken.cloud/math%E5%BA%93/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/math%E5%BA%93/</guid><description>浮点数保留N位小数 1 2 3 4 5 6 7 8 9 // 2代表精度，这种方式会有小数点后无效的0的情况 strconv.FormatFloat(123.123 &amp;#39;f&amp;#39;, 2, 64) // 效果同上 fmt.</description></item><item><title/><link>https://www.ryken.cloud/net%E5%BA%93/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/net%E5%BA%93/</guid><description/></item><item><title/><link>https://www.ryken.cloud/nginx-%E5%86%85%E9%83%A8%E6%B5%81%E7%A8%8B/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/nginx-%E5%86%85%E9%83%A8%E6%B5%81%E7%A8%8B/</guid><description>1. reload 流程 第三步master进程可能引入了新的监听端口，子进程会继承父进程所有已经打开的端口。 master收到quit信号会优雅的关闭子进程。 调用reload之后，master会使用新的配置文件启动新的worker进程，旧的worker进程关闭监听句柄，并在处理完当前的连接请求之后结束进程，如果客户端请求一直被阻塞长时间等待处理不了，nginx有对应的nginx配置项 worker-timeout-shutdown，指定时间之后进程会被强制退出。 2. 热升级的流程 升级 备份nginx可执行文件 向nginx master发送信号进行热部署 kill -USR2 pid，此时会启动一个新的nginx master 若向老的nginx matser发送优雅关闭的请求kill -WINCH pid，老的worker进行会优雅退出，但是老的master 还在运行，即允许在使用新版本出现问题时做版本回退 若向老的nginx matser发送优雅关闭的请求kill -QUIT pid，老的master也会优雅退出 回退 向老的nginx master发送HUP信号【reload命令】，向新的nginx master发送QUIT优雅退出信号</description></item><item><title/><link>https://www.ryken.cloud/nginx-%E5%91%BD%E4%BB%A4%E8%A1%8C/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/nginx-%E5%91%BD%E4%BB%A4%E8%A1%8C/</guid><description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 root@orange:/opt/nginx/conf# nginx -?</description></item><item><title/><link>https://www.ryken.cloud/nginx-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E4%BB%A5%E5%8F%8A%E5%AE%89%E8%A3%85/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/nginx-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E4%BB%A5%E5%8F%8A%E5%AE%89%E8%A3%85/</guid><description>官方地址： https://nginx.org/ 通过编译安装才会将强大的第三方模块引入nginx 文件结构
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 root@orange:~/nginx-1.</description></item><item><title/><link>https://www.ryken.cloud/nginx-%E6%9E%B6%E6%9E%84/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/nginx-%E6%9E%B6%E6%9E%84/</guid><description>抛出问题 为什么nginx使用master-worker的进程架构模型 为什么worker进程数量要与cpu的核数相匹配 多个worker之间共享数据时，为什么在TLS/限流/限速的共享方式不同 nginx 请求的处理流程 使用了非阻塞的事件驱动模型，因此使用状态机进行正确的识别和处理请求，nginx用作反向代理和静态资源服务器。 nginx用作静态资源当内存不足以缓存所有信息时，一些sendFile或者AIO会退化为阻塞的磁盘调用因此使用了线程池。 nginx用作反向代理时使用特定的协议将请求代理出去。 nginx进程结构 单进程结构 - 用于开发调式 多进程结构 - 用于实际的生产环境，nginx可以利用多核的特性 使用多进程模型而非多线程模型，保证了高可用性和高可靠性。如果使用多线程的模型，线程之间共享同一个地址空间，如果nginx导入的第三方模块引发一个地址空间导致的段错误时，整个nginx进程就会挂掉，而多进程模型就不会有这样的问题。</description></item><item><title/><link>https://www.ryken.cloud/nginx-%E7%AE%80%E4%BB%8B/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/nginx-%E7%AE%80%E4%BB%8B/</guid><description>主流的web 服务器有：Nginx、Apache、Tomcat，可以搭建网站或者反向代理服务器。
1. Nginx主要的应用场景 web请求先经过nginx，再到我们的应用服务，再到后面的数据库服务mysql、redis等，因为我们的应用开发效率高，所以其运行效率就会低，其QPS、TPS、并发受限，因此将很多的这样的一个应用服务组成一个集群提高高可用性，一旦形成集群就要求nginx具有反向代理功能，考虑容灾和动态扩容要求反向代理具备负载均衡 在整个链路当中，nginx处于企业内网的边缘节点，随着网络链路的增长用户体验的时延会增加，因此将一段时间不变的动态内容缓冲到nginx中直接向用户提供访问 访问一些jss、图片等静态资源时，无需由应用服务来访问，由系统上放置的本地文件资源直接由nginx提供访问就可以 数据库服务业务场景简单，其QPS/TPS好于应用服务程序，因此由nginx直接访问数据库服务 &amp;ndash; API服务 强大的业务处理能力 2. Nginx 出现的原因 Apache处理一个连接对应一个进程，导致进程间切换代价高，同时当连接数多时，无法开启那么多的进程。 在多核的架构下 摩尔定律失效了【芯片中的晶体管和电阻器的数量每年会翻番】 3.</description></item><item><title/><link>https://www.ryken.cloud/nginx-%E9%85%8D%E7%BD%AE%E4%B8%80%E4%B8%AA%E5%85%B7%E6%9C%89%E7%BC%93%E5%86%B2%E5%8A%9F%E8%83%BD%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/nginx-%E9%85%8D%E7%BD%AE%E4%B8%80%E4%B8%AA%E5%85%B7%E6%9C%89%E7%BC%93%E5%86%B2%E5%8A%9F%E8%83%BD%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/</guid><description>使用之前的作为一个上游服务再搭建一个反向代理服务器
安装openresty： https://openresty.org/cn/linux-packages.html，openresty默认的工作路径：/usr/local/openresty/nginx 可以将请求按照负载均衡算法反向代理给多台上游服务器工作，这样就实现了水平扩展，在用户无感知的情况下增加服务器来提高处理性能，而当上游服务器出现问题时，nginx会将自动的将请求由出现灾难的服务器转交给正常的服务器。
设置缓冲功能
设置缓冲存放的路径，设置cache的名称，开辟的共享内存，key要放置在共享内存中， 设置指定url使用的共享内存 同一个url 可能对不同的用户展示的内容是不同的，因此将用户设置到key中 设置哪些响应不返回 上游服务器通常是不提供公网访问的，因此将之前的静态服务器作为上游服务，将server中的listen 8080修改为listen 127.0.0.1:8080;
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 root@orange:~/nginx/nginx-test# cat /usr/local/openresty/nginx/conf/nginx.</description></item><item><title/><link>https://www.ryken.cloud/nginx-%E9%85%8D%E7%BD%AE%E4%B8%80%E4%B8%AA%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%9C%8D%E5%8A%A1%E5%99%A8/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/nginx-%E9%85%8D%E7%BD%AE%E4%B8%80%E4%B8%AA%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%9C%8D%E5%8A%A1%E5%99%A8/</guid><description>配置文件 location：后面为/ 表示所有请求 指定url的后缀与文件目录后缀一一对应： root：会将url中的路径带到文件路径中来 alias：（通常使用）[
]( https://blog.csdn.net/z920954494/article/details/52132125) gzip：启动gzip压缩 gzip_min_length：压缩的最小字节数 gzip_comp_level：压缩等级 gzip_types：针对某些类型的文件进行压缩
1 2 3 4 gzip on; gzip_min_length 1; # 小于1字节的不再压缩 gzip_comp_level 2; gzip_types text/plain application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png; autoindex：当访问的url以/结尾时可以对应到这个目录中的文件结构 set $limit_rate设置nginx向客户浏览器发送响应的速度，limit_rate是core moudle中的内置变量，单位字节 &amp;ndash; 限制带宽</description></item><item><title/><link>https://www.ryken.cloud/nginx-%E9%85%8D%E7%BD%AE%E8%AF%AD%E6%B3%95/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/nginx-%E9%85%8D%E7%BD%AE%E8%AF%AD%E6%B3%95/</guid><description>配置文件通用语法 有的指令块有名字，有的指令块没有名字，这取决于提供指令块的nginx子模块决定。 http配置的指令块
server：对应的一个或一组域名 http：里面的所有的指令都是由http模块去解析/执行 upstream：上游服务 location：url表达式</description></item><item><title/><link>https://www.ryken.cloud/pprof/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/pprof/</guid><description>下载cpu profile，默认从当前开始收集30s的cpu使用情况，需要等待30sgo tool pprof http://localhost:6060/debug/pprof/profile # 30-second CPU profilego tool pprof http://localhost:6060/debug/pprof/profile?seconds=120 # wait 120s# 下载heap profilego tool pprof http://localhost:6060/debug/pprof/heap # heap profile# 下载goroutine profilego tool pprof http://localhost:6060/debug/pprof/goroutine # goroutine profile# 下载block profilego tool pprof http://localhost:6060/debug/pprof/block # goroutine blocking profile# 下载mutex profilego tool pprof http://localhost:6060/debug/pprof/mutex go tool pprof http://localhost:6060/debug/pprof/heap Fetching profile over HTTP from http://localhost:6060/debug/pprof/heapSaved profile in /home/ubuntu/pprof/pprof.</description></item><item><title/><link>https://www.ryken.cloud/reflect%E5%BA%93/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/reflect%E5%BA%93/</guid><description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 func Copy(dst, src Value) int func DeepEqual(x, y interface{}) bool func Swapper(slice interface{}) func(i, j int) type ChanDir func (d ChanDir) String() string type Kind func (k Kind) String() string type MapIter func (it *MapIter) Key() Value func (it *MapIter) Next() bool func (it *MapIter) Value() Value type Method type SelectCase type SelectDir type SliceHeader type StringHeader type StructField type StructTag func (tag StructTag) Get(key string) string func (tag StructTag) Lookup(key string) (value string, ok bool) type Type func ArrayOf(count int, elem Type) Type func ChanOf(dir ChanDir, t Type) Type func FuncOf(in, out []Type, variadic bool) Type func MapOf(key, elem Type) Type func PtrTo(t Type) Type func SliceOf(t Type) Type func StructOf(fields []StructField) Type func TypeOf(i interface{}) Type type Value func Append(s Value, x .</description></item><item><title/><link>https://www.ryken.cloud/slice%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/slice%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</guid><description>slice的底层机制 切片之后共享一块空间【指针】，需要触发cap不足才会去扩容
1 2 3 4 5 type slice struct { array unsafe.Pointer len int cap int } 1.</description></item><item><title/><link>https://www.ryken.cloud/sync.map-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/sync.map-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</guid><description>sync.map底层实现 sync.map 采用读写分离技术，用空间换时间 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 type Map struct { mu Mutex read atomic.</description></item><item><title/><link>https://www.ryken.cloud/sync.Map/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/sync.Map/</guid><description>amended 为 fase，说明 dirty 为空，那直接返回 空和 false amended 为 true，说明 dirty 中可能存在我们要找的 key。 read.amended为true代表dirty map中含有read.map中没有的元素
store 如果 dirty为空 read中有直接改，修改成功 read中有但是read没有修改成功 read 对应key的value为空，确定dirty不为空，插入到dirty中 read 对应key的value不为空，更新entry</description></item><item><title/><link>https://www.ryken.cloud/sync.Mutex%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/sync.Mutex%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</guid><description>用一张图说明go中的Mutex的演变 初期使用一个flag标记，是否有人在持有锁。 考虑goroutine的唤醒机制性能低下的问题，让申请获取锁的goroutine自旋获取锁，如果固定次数获取不到之后，继续阻塞等待. 让新来的和刚刚唤醒的goroutine继续进行自旋一段时间来获取锁 多给了新人和唤醒的goroutine机会，会导致一些goroutine一直拿不到锁，因此加入了饥饿模式 Mutex底层实现 源码位置：src/sync/mutex.go，Mutex也是简单的实现了Lock和Unlock方法
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 type Locker interface { Lock() Unlock() } type Mutex struct { state int32 sema uint32 } const ( mutexLocked = 1 &amp;lt;&amp;lt; iota // mutex is locked mutexWoken mutexStarving // 从state字段中分出一个饥饿标记 mutexWaiterShift = iota starvationThresholdNs = 1e6 ) // mutexLocked，mutexWoken，mutexStarving，mutexWaiterShift 的值分别是1，2，4，3。 // starvationThresholdNs = 1e6 表示1ms内如果被唤醒的协程还没有抢到锁，就进入饥饿状态，可以直接获取锁。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 func (m *Mutex) Lock() { // Fast path: grab unlocked mutex.</description></item><item><title/><link>https://www.ryken.cloud/sync.RWMutex%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/sync.RWMutex%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</guid><description>底层实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 type RWMutex struct { w Mutex // held if there are pending writers writerSem uint32 // semaphore for writers to wait for completing readers readerSem uint32 // semaphore for readers to wait for completing writers readerCount int32 // number of pending readers readerWait int32 // number of departing readers } const rwmutexMaxReaders = 1 &amp;lt;&amp;lt; 30 func (rw *RWMutex) RLock() {.</description></item><item><title/><link>https://www.ryken.cloud/sync.WaitGroup%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/sync.WaitGroup%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</guid><description>WaitGroup底层实现原理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 type WaitGroup struct { noCopy noCopy state1 [3]uint32 } // noCopy 是 golang 源码中检测禁止拷贝的技术，在不考虑内存对齐和并发的因素下可以将其看为如下结构 type WaitGroup struct { counter int32 waiter uint32 sema uint32 } // count：代表目前尚未完成的个数 // waiter：代表目前已经调用waitGroup.</description></item><item><title/><link>https://www.ryken.cloud/sync_atomic/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/sync_atomic/</guid><description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 func AddInt32(addr *int32, delta int32) (new int32) func AddInt64(addr *int64, delta int64) (new int64) func AddUint32(addr *uint32, delta uint32) (new uint32) func AddUint64(addr *uint64, delta uint64) (new uint64) func AddUintptr(addr *uintptr, delta uintptr) (new uintptr) func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool) func CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool) func CompareAndSwapPointer(addr *unsafe.</description></item><item><title/><link>https://www.ryken.cloud/sync%E5%BA%93/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/sync%E5%BA%93/</guid><description>类型与方法总览 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 type Cond func NewCond(l Locker) *Cond func (c *Cond) Broadcast() func (c *Cond) Signal() func (c *Cond) Wait() type Locker type Map func (m *Map) Delete(key interface{}) func (m *Map) Load(key interface{}) (value interface{}, ok bool) func (m *Map) LoadAndDelete(key interface{}) (value interface{}, loaded bool) func (m *Map) LoadOrStore(key, value interface{}) (actual interface{}, loaded bool) func (m *Map) Range(f func(key, value interface{}) bool) func (m *Map) Store(key, value interface{}) type Mutex func (m *Mutex) Lock() func (m *Mutex) Unlock() type Once func (o *Once) Do(f func()) type Pool func (p *Pool) Get() interface{} func (p *Pool) Put(x interface{}) type RWMutex func (rw *RWMutex) Lock() func (rw *RWMutex) RLock() func (rw *RWMutex) RLocker() Locker func (rw *RWMutex) RUnlock() func (rw *RWMutex) Unlock() type WaitGroup func (wg *WaitGroup) Add(delta int) func (wg *WaitGroup) Done() func (wg *WaitGroup) Wait() WaitGroup实现协程间同步 WaitGroup对象内部有一个计数器，最初从0开始，有三个方法来控制计数器的数量</description></item><item><title/><link>https://www.ryken.cloud/%E4%B9%90%E8%A7%82%E9%94%81%E6%82%B2%E8%A7%82%E9%94%81%E8%87%AA%E6%97%8B%E9%94%81/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E4%B9%90%E8%A7%82%E9%94%81%E6%82%B2%E8%A7%82%E9%94%81%E8%87%AA%E6%97%8B%E9%94%81/</guid><description>乐观锁和悲观锁并不是一种真实存在的锁，而是一种设计思想。
悲观锁总认为最坏的情况可能会出现，认为数据很可能会被其他人所修改，所以悲观锁在持有数据的时候总会把资源/数据 锁住，这样其他线程想要请求这个资源的时候就会阻塞，直到等到悲观锁把资源释放为止。 乐观锁的思想与悲观锁的思想相反，它总认为资源和数据不会被别人所修改，所以读取不会上锁，但是乐观锁在进行写入操作的时候会判断当前数据是否被修改过 CAS或版本号机制。 自旋锁：只有获取了锁的线程才能对资源进行访问，由于同一时刻只能有一个线程获取到锁。没有获取到锁的线程就一直循环等待判断该资源是否已经释放锁，这种锁叫做自旋锁，它不用将线程阻塞起来，还有一种处理方式就是把自己阻塞起来，等待重新调度请求，这种叫做互斥锁。</description></item><item><title/><link>https://www.ryken.cloud/%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93/</guid><description>CGO在使用C/C++资源的时候一般有三种形式：直接使用源码、链接静态库、链接动态库。直接使用源码就是在import &amp;quot;C&amp;quot;之前的注释部分包含C代码，或者在当前包中包含C/C++源文件。链接静态库和动态库的方式比较类似，都是通过在LDFLAGS选项指定要链接的库方式链接。
gcc生成静态库/动态库 | ar -rc libxxx.a xxx.o（正确方法） ar -rc libxxx.a xxx1.c （可以生成静态库；运行可执行程序会报错：could not read symbols:Archive has no index;run ranlib to add one）</description></item><item><title/><link>https://www.ryken.cloud/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/</guid><description>CGO技术不仅可以在Go语言中调用C语言函数，也可以将Go语言函数导出为C语言函数
go调用C函数 启用CGO特性后，CGO会构造一个虚拟的C包。通过这个虚拟的C包可以调用C语言函数。
C函数的返回值 C语言不支持返回多个结果，因此&amp;lt;errno.h&amp;gt;标准库提供了一个errno宏用于返回错误状态。我们可以近似地将errno看着一个线程安全的全局变量，可以用于记录最近一次错误的状态码。 CGO也针对&amp;lt;errno.h&amp;gt;标准库的errno宏做的特殊支持：在CGO调用C函数时如果有两个返回值，那么第二个返回值将对应errno错误状态。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /* #include &amp;lt;errno.</description></item><item><title/><link>https://www.ryken.cloud/%E5%9C%A8%E5%AE%B9%E5%99%A8%E5%86%85%E8%8E%B7%E5%8F%96Pod%E4%BF%A1%E6%81%AF/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E5%9C%A8%E5%AE%B9%E5%99%A8%E5%86%85%E8%8E%B7%E5%8F%96Pod%E4%BF%A1%E6%81%AF/</guid><description>每个Pod在被成功创建出来之后，都会被系统分配唯一的名字、IP地址，并且处于某个Namespace中，那么我们如何在Pod的容器内获取Pod的这些重要信息呢？答案就是使用Downward API。
Downward API有什么价值 在某些集群中，集群中的每个节点都需要将自身的标识（ID）及进程绑定的IP地址等信息事先写入配置文件中，进程在启动时会读取这些信息，然后将这些信息发布到某个类似服务注册中心的地方，以实现集群节点的自动发现功能。此时Downward API就可以派上用场了，具体做法是先编写一个预启动脚本或Init Container，通过环境变量或文件方式获取Pod自身的名称、IP地址等信息，然后将这些信息写入主程序的配置文件中，最后启动主程序。
Downward API可以通过以下两种方式将Pod信息注入容器内部。
环境变量：用于单个变量，可以将Pod信息和Container信息注入容器内部。 Volume挂载：将数组类信息生成为文件并挂载到容器内部。 环境变量注入容器内部【pod信息+container信息】 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 apiVersion:v1kind:Podmetadata:name:dapi-test-podspec:containers:- name:test-containerimage:busyboxcommand:[&amp;#34;/bin/sh&amp;#34;,&amp;#34;-c&amp;#34;,&amp;#34;env&amp;#34;]env:- name:MY_POD_NAMEvalueFrom:fieldRef:fieldPath:metadata.</description></item><item><title/><link>https://www.ryken.cloud/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</guid><description>Q1 = 和 := 的区别？ := 声明+赋值； = 仅赋值 简短声明模式的限制：
定义变量同时显示初始化 不能提供数据类型 只能在函数内部使用 1 2 3 4 var foo int foo = 10 // 等价于 foo := 10 编译执行下面代码的结果 1 2 3 4 5 6 7 8 9 10 package main var( size :=1024 max_size = size*2 ) func main() { println(size,max_size) } // syntax error: unexpected := Q2 常量 常量不同于变量，变量在运行时分配内存，常量通常在被编译器在预处理阶段直接展开，作为指令数据直接使用。</description></item><item><title/><link>https://www.ryken.cloud/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BC%A0%E5%85%A5%E4%BC%A0%E5%87%BA%E5%8F%82%E6%95%B0/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BC%A0%E5%85%A5%E4%BC%A0%E5%87%BA%E5%8F%82%E6%95%B0/</guid><description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 //#include &amp;lt;string.</description></item><item><title/><link>https://www.ryken.cloud/%E5%B0%81%E8%A3%85qsort/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E5%B0%81%E8%A3%85qsort/</guid><description>qsort快速排序函数有&amp;lt;stdlib.h&amp;gt;标准库提供，函数的声明如下：
1 2 3 4 void qsort( void* base, size_t num, size_t size, int (*cmp)(const void*, const void*) ); 其中base参数是要排序数组的首个元素的地址，num是数组中元素的个数，size是数组中每个元素的大小。最关键是cmp比较函数，用于对数组中任意两个元素进行排序。cmp排序函数的两个指针参数分别是要比较的两个元素的地址，如果第一个参数对应元素大于第二个参数对应的元素将返回结果大于0，如果两个元素相等则返回0，如果第一个元素小于第二个元素则返回结果小于0。</description></item><item><title/><link>https://www.ryken.cloud/%E5%BE%85%E5%8A%9E%E4%BA%8B%E9%A1%B9/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E5%BE%85%E5%8A%9E%E4%BA%8B%E9%A1%B9/</guid><description>总结interface与reflect &amp;ndash; go类型 sync/atomic golang相关的面试题 7days相关的总结 &amp;ndash; rpc值类型与指针类型处理有些许差异 反射映射为服务并完成函数的调用的实现比较巧妙 类型 组合</description></item><item><title/><link>https://www.ryken.cloud/%E6%97%A0%E6%A0%87%E9%A2%98/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E6%97%A0%E6%A0%87%E9%A2%98/</guid><description>内存 tcmalloc - 大小对象分级、多核缓冲
gc策略： 标记-清扫 === 内存碎片 标记-压缩 === 计算位置、forward指针，实现复杂 半空间复制</description></item><item><title/><link>https://www.ryken.cloud/%E6%97%B6%E9%97%B4%E6%93%8D%E4%BD%9C/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E6%97%B6%E9%97%B4%E6%93%8D%E4%BD%9C/</guid><description>计算2个时间差 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;time&amp;#34; ) func main() { //Add方法和Sub方法是相反的，获取t0和t1的时间距离d是使用Sub //将t0加d获取t1就是使用Add方法 k := time.</description></item><item><title/><link>https://www.ryken.cloud/%E6%9E%84%E5%BB%BA%E7%BA%A6%E6%9D%9F%E9%97%AE%E9%A2%98/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E6%9E%84%E5%BB%BA%E7%BA%A6%E6%9D%9F%E9%97%AE%E9%A2%98/</guid><description>go构建约束问题，Build constraints exclude all Go files in ？ 我的情况是使用了CGO，但是编译的时候没有加上CGO_ENABLED=1 有的情况下，也有可能是GOOS环境的问题 // +build linux,amd64,go1.15,!cgo</description></item><item><title/><link>https://www.ryken.cloud/%E6%A8%A1%E5%9D%97%E7%AE%80%E4%BB%8B/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E6%A8%A1%E5%9D%97%E7%AE%80%E4%BB%8B/</guid><description> 初识nginx nginx架构基础 nginx的数据结构和进程模型 详解http模块 nginx如何处理http请求 常用的实例、变量 反向代理与负载均衡 nginx的系统层优化 从源码视角深入使用nginx与OpenResty</description></item><item><title/><link>https://www.ryken.cloud/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</guid><description>C中的类型 在Go语言中访问C语言的符号时，一般是通过虚拟的“C”包访问。Go语言中数值类型和C语言数据类型基本上是相似的，它们的对应关系表如下：
C语言类型 CGO类型 Go语言类型 char C.char byte singed char C.</description></item><item><title/><link>https://www.ryken.cloud/%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86-configMap/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86-configMap/</guid><description>从Kubernetes 1.2开始提供了一种统一的应用配置管理方案—ConfigMap。ConfigMap以一个或多个key:value的形式保存在Kubernetes系统中供应用使用，既可以用于表示一个变量的值（例如apploglevel=info），也可以用于表示一个完整配置文件的内容。
configMap的使用场景 生成为容器内的环境变量。 设置容器启动命令的启动参数（需设置为环境变量）。 以Volume的形式挂载为容器内部的文件或目录。 创建configMap kubectl通过yaml配置文件创建 kubectl create -f cm-appvars.yaml
将应用所需要的变量定义为configMap 将配置文件定义为configmap 1 2 3 4 5 6 7 apiVersion:v1kind:ConfigMapmetadata:name:cm-appvarsdata:apploglevel:infoappdatadir:/var/data 1 2 3 4 5 6 7 8 9 10 11 12 13 14 apiVersion:v1kind:ConfigMapmetadata:name:cm-appconfigfilesdata:key-serverxml:|&amp;lt;?</description></item><item><title/><link>https://www.ryken.cloud/%E9%9D%99%E6%80%81Pod/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E9%9D%99%E6%80%81Pod/</guid><description>特性 静态Pod是由kubelet进行管理的仅存在于特定Node上的Pod。它们不能通过API Server进行管理，无法与ReplicationController、Deployment或者DaemonSet进行关联，并且kubelet无法对它们进行健康检查。静态Pod总是由kubelet创建的，并且总在kubelet所在的Node上运行。
创建方式：配置文件创建和http方式创建 配置文件创建： 设置kubelet的启动参数“&amp;ndash;config”，指定kubelet需要监控的配置文件所在的目录，kubelet会定期扫描该目录，并根据该目录下的.yaml或.json文件进行创建操作。
假设配置目录为/etc/kubelet.d/，配置启动参数为&amp;ndash;config=/etc/kubelet.d/，然后重启kubelet服务。
1 2 3 4 5 6 7 8 9 10 11 12 13 apiVersion:v1kind:Podmetadata:name:static-weblabels:name:static-webspec:containers:- name:static-webimages:nginxports:- name:webcontainerPort:80 由于静态Pod无法通过API Server直接管理，所以在Master上尝试删除这个Pod时，会使其变成Pending状态，且不会被删除。删除该Pod的操作只能是到其所在Node上将其定义文件从指定的(/etc/kubelet.</description></item><item><title>1-11</title><link>https://www.ryken.cloud/1-11/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/1-11/</guid><description>原文链接： https://studygolang.com/articles/10065 https://studygolang.com/articles/11003 https://studygolang.com/articles/10746 https://studygolang.com/articles/10994
1. defer执行顺序 1 2 3 4 5 6 7 8 9 10 11 12 func defer_call() { defer func() { fmt.</description></item><item><title>epoll的LT模式与ET模式</title><link>https://www.ryken.cloud/epoll%E7%9A%84LT%E6%A8%A1%E5%BC%8F%E4%B8%8EET%E6%A8%A1%E5%BC%8F/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/epoll%E7%9A%84LT%E6%A8%A1%E5%BC%8F%E4%B8%8EET%E6%A8%A1%E5%BC%8F/</guid><description>epoll的LT模式与ET模式哪个效率更高
LT和ET的区别： LT对于存在未读完的数据，下一次调用epoll_wait还会触发， ET无论是否读完，只触发一次，直到下一次EPOLLIN事件到来
LT的优点：易于编码，未读完的数据下次还能继续读，不易遗漏 ET的缺点：难以编码，需要一次读完，有时会遗漏
LT的缺点：在并发量高的时候，epoll_wait返回的就绪队列比较大，遍历比较耗时。因此LT适用于并发量小的情况 ET的优点：并发量大的时候，就绪队列要比LT小得多，效率更高
应用 使用ET的例子：nginx 使用LT的例子：redis 选取参考（nginx选用ET）
看连接的空闲程度，连接的空闲程度很高就用ET，所以按照场景，http的客户端idel情况很高，用ET，如果是rpg的游戏服务器，用LT，ET差不多</description></item><item><title>git submodule</title><link>https://www.ryken.cloud/git-submodule/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/git-submodule/</guid><description>下载了项目之后初始化子模块 git submodule update &amp;ndash;init &amp;ndash;recursive 添加子模块 git submodule add url path git submodule add -b dev https://github.com/xx/xx content 删除子模块 删除文件 rm -rf content/ - 删除项目目录下.</description></item><item><title>git proxy</title><link>https://www.ryken.cloud/git-proxy/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/git-proxy/</guid><description>git 设置和取消代理 (github.com)
windows git 设置代理 简单方法： 设置环境变量
http_proxy: 127.0.0.1:1080 https_proxy: 127.0.0.1:1080 windows git 相关的配置文件：C:\Users\renyunkang\.gitconfig
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 [user] email = rykren1998@gmail.</description></item><item><title>git 文档</title><link>https://www.ryken.cloud/git-%E6%96%87%E6%A1%A3/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/git-%E6%96%87%E6%A1%A3/</guid><description> **feat：**提交新功能 fix：修复了bug docs：只修改了文档 style：调整代码格式，未修改代码逻辑（比如修改空格、格式化、缺少分号等） refactor：代码重构，既没修复bug也没有添加新功能 perf：性能优化，提高性能的代码更改 test：添加或修改代码测试 chore：对构建流程或辅助工具和依赖库（如文档生成等）的更改</description></item><item><title>Pod</title><link>https://www.ryken.cloud/Pod/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/Pod/</guid><description>Pod是Kubernetes最重要的基本概念，每个Pod都有一个特殊的被称为“根容器”的Pause容器。除了Pause容器，每个Pod还包含一个或多个紧密相关的用户业务容器。 pause 容器： 引入业务无关并且不易死亡的Pause容器作为Pod的根容器，以它的状态代表整个容器组的状态。 Pod里的多个业务容器共享Pause容器的IP，共享Pause容器挂接的Volume，这样既简化了密切关联的业务容器之间的通信问题，也很好地解决了它们之间的文件共享问题。 Pod的网络： Kubernetes为每个Pod都分配了唯一的IP地址，称之为Pod IP。
Pod内网络：一个Pod里的多个容器共享Pod IP地址。 Pod间网络：一个Pod里的容器与另外主机上的Pod容器能够直接通信。因为Kubernetes要求底层网络支持集群内任意两个Pod之间的TCP/IP直接通信，这通常采用虚拟二层网络技术来实现，例如Flannel、Open vSwitch等。 Pod类型 静态Pod：并没被存放在Kubernetes的etcd存储里，而是被存放在某个具体的Node上的一个具体文件中，并且只在此Node上启动、运行。 普通Pod：一旦被创建，就会被放入etcd中存储，随后会被Kubernetes Master调度到某个具体的Node上并进行绑定，随后该Pod被对应的Node上的kubelet进程实例化成一组相关的Docker容器并启动。在默认情况下，当Pod里的某个容器停止时，Kubernetes会自动检测到这个问题并且重新启动这个Pod（重启Pod里的所有容器），如果Pod所在的Node宕机，就会将这个Node上的所有Pod重新调度到其他节点上。 图Pod、容器与Node的关系</description></item><item><title>runtime</title><link>https://www.ryken.cloud/runtime/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/runtime/</guid><description>crio
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # 1.</description></item><item><title>ssh 首次连接自动化输入 yes</title><link>https://www.ryken.cloud/ssh-%E9%A6%96%E6%AC%A1%E8%BF%9E%E6%8E%A5%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BE%93%E5%85%A5-yes/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/ssh-%E9%A6%96%E6%AC%A1%E8%BF%9E%E6%8E%A5%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BE%93%E5%85%A5-yes/</guid><description>sshpass -p PASSWORD ssh -o StrictHostKeyChecking=no root@${ip1}'echo 1' 避免交互输入密码 sshpass -p PASSWORD scp xx xx@xxx:/xx</description></item><item><title>一个简单的例子</title><link>https://www.ryken.cloud/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BE%8B%E5%AD%90/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BE%8B%E5%AD%90/</guid><description>一个运行在Tomcat里的Web App，JSP页面通过JDBC直接访问MySQL数据库并展示数据。该例子只要程序正确连接到了数据库，就会自动完成对应的表的创建与初始化数据的准备工作。所以，当我们通过浏览器访问此应用时，就会显示一个表格的页面，数据则来自数据库。 启动两个容器：Web App容器和MySQL容器，并且Web App容器需要访问MySQL容器。在Docker时代，假设我们在一个宿主机上启动了这两个容器，就需要把MySQL容器的IP地址通过环境变量注入Web App容器里；同时，需要将Web App容器的8080端口映射到宿主机的8080端口，以便在外部访问。
创建mysql服务： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 apiVersion:v1kind:ReplicationControllermetadata:name:mysqlspec:replicas:1selector:app:mysqltemplate:metadata:labels:app:mysqlspec:containers:- name:mysqlimage:mysql:5.</description></item><item><title>共享Pod级 volume</title><link>https://www.ryken.cloud/%E5%85%B1%E4%BA%ABPod%E7%BA%A7-volume/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E5%85%B1%E4%BA%ABPod%E7%BA%A7-volume/</guid><description>在Pod内包含两个容器：tomcat和busybox，在Pod级别设置Volume“app-logs”，用于tomcat向其中写日志文件，busybox读日志文件。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 apiVersion:v1kind:Podmetadata:name:volume-podspec:containers:- name:tomcatimage:kubeguide/tomcat-app:v1ports:- containerPort:8080volumeMounts:- name:app-logsmountPath:/usr/local/tomcat/logs- name:Ubuntuimage:Ubuntu:latestcommand:[&amp;#34;sh&amp;#34;,&amp;#34;-c&amp;#34;,&amp;#34;tail -f /logs/catalina*.</description></item><item><title>内核参数</title><link>https://www.ryken.cloud/%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0/</guid><description>ipvs warn 关闭 - 当ipvs连不上后端时会打印相关的报错信息 sysctl -w net.ipv4.vs.ignore_no_rs_error=1 IPVS no destination available - Kubernetes 实践指南 (imroc.cc)</description></item><item><title>端口关系</title><link>https://www.ryken.cloud/%E7%AB%AF%E5%8F%A3%E5%85%B3%E7%B3%BB/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E7%AB%AF%E5%8F%A3%E5%85%B3%E7%B3%BB/</guid><description> type=NodePort和nodePort=30001的两个属性表明此Service开启了NodePort方式的外网访问模式。</description></item><item><title>1. OFN Overview</title><link>https://www.ryken.cloud/1.-OFN-Overview/</link><pubDate>Mon, 01 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/1.-OFN-Overview/</guid><description>1 2 list from &amp;#34;CloudNative/Faas-ofn&amp;#34; sort file.name 架构图</description></item><item><title>2. OFN Install</title><link>https://www.ryken.cloud/2.-OFN-Install/</link><pubDate>Mon, 01 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/2.-OFN-Install/</guid><description>安装 helm repo add openfunction https://openfunction.github.io/charts/ helm repo update kubectl create namespace openfunction helm install openfunction openfunction/openfunction -n openfunction 安装前后对比图： v1.</description></item><item><title>4. OFN Gateway</title><link>https://www.ryken.cloud/4.-OFN-Gateway/</link><pubDate>Mon, 01 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/4.-OFN-Gateway/</guid><description/></item><item><title>arp proxy</title><link>https://www.ryken.cloud/arp-proxy/</link><pubDate>Mon, 01 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/arp-proxy/</guid><description>1 2 3 4 sudo bash -c &amp;#39;echo 1 &amp;gt; /proc/sys/net/ipv4/ip_forward&amp;#39; cat /proc/sys/net/ipv4/conf/eth1/proxy_arp sudo sysctl -p 添加默认路由</description></item><item><title>centos 配置网络文件</title><link>https://www.ryken.cloud/centos-%E9%85%8D%E7%BD%AE%E7%BD%91%E7%BB%9C%E6%96%87%E4%BB%B6/</link><pubDate>Mon, 01 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/centos-%E9%85%8D%E7%BD%AE%E7%BD%91%E7%BB%9C%E6%96%87%E4%BB%B6/</guid><description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 cat /etc/sysconfig/network-scripts/ifcfg-eth0 # Created by cloud-init on instance boot automatically, do not edit.</description></item><item><title>hybridnet 网络插件</title><link>https://www.ryken.cloud/hybridnet-%E7%BD%91%E7%BB%9C%E6%8F%92%E4%BB%B6/</link><pubDate>Mon, 01 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/hybridnet-%E7%BD%91%E7%BB%9C%E6%8F%92%E4%BB%B6/</guid><description>[[vlan 配置]]
一键安装 1 2 3 helm repo add hybridnet https://alibaba.github.io/hybridnet/ helm repo update helm install hybridnet hybridnet/hybridnet -n kube-system --set init.</description></item><item><title>Q&amp;A</title><link>https://www.ryken.cloud/QA/</link><pubDate>Mon, 01 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/QA/</guid><description>what is gateway service? 假设您正在使用 Kourier 作为 Knative 的网络层? 修改配置使用节点的 ip 作为 external-ip 使用。 how to do?</description></item><item><title>vlan 配置</title><link>https://www.ryken.cloud/vlan-%E9%85%8D%E7%BD%AE/</link><pubDate>Mon, 01 May 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/vlan-%E9%85%8D%E7%BD%AE/</guid><description>[[hybridnet 网络插件]]
1 2 3 4 5 6 7 set interfaces ethernet eth1 vif 100 description &amp;#39;VLAN 100&amp;#39; set interfaces ethernet eth1 vif 100 address &amp;#39;192.</description></item><item><title/><link>https://www.ryken.cloud/%E5%B7%A5%E5%85%B7%E5%88%97%E8%A1%A8/</link><pubDate>Wed, 26 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E5%B7%A5%E5%85%B7%E5%88%97%E8%A1%A8/</guid><description>#tool #linux #network
工具包 [[网络工具包]] ebpf 相关 [[ebpf 排查工具]] iptables 相关 [[iptables 转发]] conntrack/netstats/ss/lsof [[conntrack]] 网卡多队列、中断绑定 [[网卡多队列 + 中断绑定]]</description></item><item><title>calico metrics</title><link>https://www.ryken.cloud/calico-metrics/</link><pubDate>Wed, 26 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/calico-metrics/</guid><description> Prometheus statistics (tigera.io)
指标 描述 felix_active_local_endpoints 该主机上活动的 endpoints 数量 felix_active_local_policies 该主机上活跃的策略数 felix_active_local_selectors 该主机上额活跃 selectors 数 felix_calc_graph_output_events calculation graph 产生的事件数 felix_calc_graph_update_time_seconds 为每个 datastore更新 calculation graph 调用 OnUpdate的秒 felix_calc_graph_updates_processed calculation graph 处理的 datestore 更新次数 felix_cluster_num_host_endpoints 集群层面 host endpoints 的总数 felix_cluster_num_hosts 集群中的 Calico hosts 总数 felix_cluster_num_workload_endpoints 集群层负载 endpoints 总数 felix_exec_time_micros fork/exec 子进程花费的时间 felix_int_dataplane_addr_msg_batch_size 批处理的接口地址报文数。 较高的值表示我们正在做更多的批处理以试图跟上 felix_int_dataplane_apply_time_seconds 应用数据面更新花费的时间 felix_int_dataplane_failures 数据面更新失败以及重试次数 felix_int_dataplane_iface_msg_batch_size 批处理的接口状态消息数。 较高的值表示我们正在做更多的批处理以试图跟上 felix_int_dataplane_messages 按照类型分类的消息数 felix_int_dataplane_msg_batch_size 批处理的消息数。 较高的值表示我们正在做更多的批处理以试图跟上 felix_ipset_calls ipset 命令执行数 felix_ipset_errors ipset 命令失败数 felix_ipset_lines_executed ipset 执行操作数 felix_ipsets_calico active Calico IP sets 数量 felix_ipsets_total active IP sets 总数 felix_iptables_chains active iptables chains 数量 felix_iptables_lines_executed iptables 规则执行更新数 felix_iptables_restore_calls iptables-restore 调用次数 felix_iptables_restore_errors iptables-restore 错误数 felix_iptables_rules active iptables 规则数 felix_iptables_save_calls iptables-save 调用次数 felix_iptables_save_errors iptables-save 错误数 felix_resync_state 当前 datastore 状态 felix_resyncs_started felix 开始重新同步datastore的次数 felix_route_table_list_seconds 在同步期间列出所有接口所花费的时间 felix_route_table_per_iface_sync_seconds 同步每个接口所花费的时间 felix_log_errors 错误日志数 felix_logs_dropped 由于输出流被阻塞而丢弃的日志数 使用 prometheus 收集监控：[[监控 - monitor]] 使用可视化查看：[[grafana 可视化]]</description></item><item><title>coredns</title><link>https://www.ryken.cloud/coredns/</link><pubDate>Wed, 26 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/coredns/</guid><description>coredns &amp;ldquo;no nameservers found&amp;rdquo; error coredns CrashLoopBackOff
1 kubectl edit configmap coredns -n kube-system 删除以下部分或者修改为正确的 dns
1 2 3 forward .</description></item><item><title>DNS</title><link>https://www.ryken.cloud/DNS/</link><pubDate>Wed, 26 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/DNS/</guid><description>亚马逊 DNS - routeD5? 可以实现跨地域级别的通信，一个地域内可以使用 bgp 去打通 Amazon Route 53</description></item><item><title>DNS 记录</title><link>https://www.ryken.cloud/DNS-%E8%AE%B0%E5%BD%95/</link><pubDate>Wed, 26 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/DNS-%E8%AE%B0%E5%BD%95/</guid><description>使用青云的公有云，有时主机重启之后对应的dns记录会消失，手动修改 /etc/resolv.conf 后重启会被覆盖，因此可以使用以下方法解决：
使用默认的 resolved 管理 DNS 记录 使用resolvconf 管理 DNS 记录 使用 resolved 修改 /etc/systemd/resolved.conf 文件，在其中添加dns信息，例如： DNS=8.</description></item><item><title>grafana 可视化</title><link>https://www.ryken.cloud/grafana-%E5%8F%AF%E8%A7%86%E5%8C%96/</link><pubDate>Wed, 26 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/grafana-%E5%8F%AF%E8%A7%86%E5%8C%96/</guid><description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 kubectl apply -f - &amp;lt;&amp;lt;EOF apiVersion: v1 kind: ConfigMap metadata: name: grafana-config namespace: calico-monitoring data: prometheus.</description></item><item><title>kube-controller-manager</title><link>https://www.ryken.cloud/kube-controller-manager/</link><pubDate>Wed, 26 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/kube-controller-manager/</guid><description>Calico kube-controller-manager 是 Deployment。它包含以下控制器：
policy controller：监视网络策略和 calico 策略，它会把Kubernetes的network policies同步到 datastore 中。 namespace controller：监视命名空间和 calico 配置文件，它会把Kubernetes的namespace label变化同步到 datastore 中。 serviceaccount controller：监视服务帐户和 calico 配置文件，它会把Kubernetes的service account变化同步到 datastore 中。 workloadendpoint controller：监视pod标签的更改并更新Calico工作负载中的endpoints配置，它会把Kubernetes的pod label变化同步到 datastore 中。 node controller：监视删除Kubernetes nodes节点的操作并从Calico中也删除相应的数据。</description></item><item><title>kubeadm install k8s</title><link>https://www.ryken.cloud/kubeadm-install-k8s/</link><pubDate>Wed, 26 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/kubeadm-install-k8s/</guid><description>ubuntu 安装 kubernetes 1. 安装 docker 安装docker：
curl -sSL https://get.daocloud.io/docker | sh curl -fsSL https://get.docker.com | bash -s docker &amp;ndash;mirror Aliyun 2.</description></item><item><title>kubekey install k8s</title><link>https://www.ryken.cloud/kubekey-install-k8s/</link><pubDate>Wed, 26 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/kubekey-install-k8s/</guid><description>下载 kubekey
1 2 export KKZONE=cn curl -sfL https://get-kk.kubesphere.io | VERSION=v2.3.0 sh - 生成配置文件
1 2 3 4 5 6 7 8 .</description></item><item><title>kubernetes</title><link>https://www.ryken.cloud/kubernetes/</link><pubDate>Wed, 26 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/kubernetes/</guid><description>[[kubeadm install k8s]] [[kubekey install k8s]] [[webhook]] [[runtime]]</description></item><item><title>kubernetes dns</title><link>https://www.ryken.cloud/kubernetes-dns/</link><pubDate>Wed, 26 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/kubernetes-dns/</guid><description>kubernetes dns 规范： dns/specification.md at master · kubernetes/dns (github.com)</description></item><item><title>kubernetes service</title><link>https://www.ryken.cloud/kubernetes-service/</link><pubDate>Wed, 26 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/kubernetes-service/</guid><description>服务（Service） | Kubernetes
externalName service： Kubernetes Tips - Part 1 (akomljen.com)</description></item><item><title>linux 网络配置</title><link>https://www.ryken.cloud/linux-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</link><pubDate>Wed, 26 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/linux-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</guid><description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 root@node1:~# cat /etc/network/interfaces source /etc/network/interfaces.</description></item><item><title>Prometheus Blockbox Exporter</title><link>https://www.ryken.cloud/Prometheus-Blockbox-Exporter/</link><pubDate>Wed, 26 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/Prometheus-Blockbox-Exporter/</guid><description>Blackbox Exporter 是 Prometheus 社区提供的 官方黑盒监控解决方案,其允许用户通过: http\HTTPS\DNS\TCP\ICMP\gRPC的方式对网络进行探测.
安装部署
docker 安装
1 docker run --rm -p 9115:9115 --name blackbox_exporter -v $(pwd):/config quay.</description></item><item><title>Submariner</title><link>https://www.ryken.cloud/Submariner/</link><pubDate>Wed, 26 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/Submariner/</guid><description> Submariner (rancher.cn)</description></item><item><title>webhook</title><link>https://www.ryken.cloud/webhook/</link><pubDate>Wed, 26 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/webhook/</guid><description>动态准入控制插件
MutatingWebhookConfiguration ValidatingWebhookConfiguration k8s webhook准入控制插件源码级别理解-注入sidecar - 知乎 (zhihu.com)
openelb webhook 使用 kube-webhook-certgen port-allocator webhook 使用 cert-manager
ks使用 helm</description></item><item><title>多网卡</title><link>https://www.ryken.cloud/%E5%A4%9A%E7%BD%91%E5%8D%A1/</link><pubDate>Wed, 26 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E5%A4%9A%E7%BD%91%E5%8D%A1/</guid><description>创建 nad
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 cat &amp;lt;&amp;lt;EOF | kubectl create -f -apiVersion:&amp;#34;k8s.</description></item><item><title>根据系统日志排查</title><link>https://www.ryken.cloud/%E6%A0%B9%E6%8D%AE%E7%B3%BB%E7%BB%9F%E6%97%A5%E5%BF%97%E6%8E%92%E6%9F%A5/</link><pubDate>Wed, 26 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E6%A0%B9%E6%8D%AE%E7%B3%BB%E7%BB%9F%E6%97%A5%E5%BF%97%E6%8E%92%E6%9F%A5/</guid><description>calico 意外重启 位于 master2 的 calico-node 在 3d2h 前意外重启，现在使用 kubectl logs查看日志为现运行时的日志，没有参考价值。可以在日志组件中检索对应 pod且在对应时间段的日志；另外可以通过 kubectl logs -p xxx 获取到重启前的日志
本次排查在日志没有明显的报错，之后查看系统日志（注意系统日志默认保留时间为 7 天）</description></item><item><title>监控 - monitor</title><link>https://www.ryken.cloud/%E7%9B%91%E6%8E%A7-monitor/</link><pubDate>Wed, 26 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E7%9B%91%E6%8E%A7-monitor/</guid><description>Monitor Calico component metrics (tigera.io)
Configure Calico to enable the metrics reporting. Create the namespace and service account that Prometheus will need.</description></item><item><title>监控文档</title><link>https://www.ryken.cloud/%E7%9B%91%E6%8E%A7%E6%96%87%E6%A1%A3/</link><pubDate>Wed, 26 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E7%9B%91%E6%8E%A7%E6%96%87%E6%A1%A3/</guid><description>calicoctl node 作用： calicoctl node run：运行 calico-node 镜像 calicoctl node status： calico-node 的一些状态信息 calicoctl node diags：为 Calico 节点收集诊断包 calicoctl node checksystem：检测该节点能否运行 calico-node 缺陷： 只能获取本节点的信息</description></item><item><title>网络工具包</title><link>https://www.ryken.cloud/%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7%E5%8C%85/</link><pubDate>Wed, 26 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7%E5%8C%85/</guid><description>相关网络工具包：
ping包：apt-get install inetutils-ping ifconfig/netstat：apt-get install net-tools ip 命令：apt-get install iproute2 抓包：sudo apt-get install wireshark + sudo usermod -a -G wireshark $USER</description></item><item><title>网络监控工具</title><link>https://www.ryken.cloud/%E7%BD%91%E7%BB%9C%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7/</link><pubDate>Wed, 26 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E7%BD%91%E7%BB%9C%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7/</guid><description>google/cadvisor: Analyzes resource usage and performance characteristics of running containers. (github.com) 网络资源的使用率
yingyan003/netChecker: netChecker是一个检查k8s集群网络连通性的工具。测试对象是pod-&amp;gt;pod，pod-&amp;gt;node，pod-&amp;gt;svc的网络状况 (github.</description></item><item><title>路由反射器的反射规则</title><link>https://www.ryken.cloud/%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8%E7%9A%84%E5%8F%8D%E5%B0%84%E8%A7%84%E5%88%99/</link><pubDate>Wed, 26 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8%E7%9A%84%E5%8F%8D%E5%B0%84%E8%A7%84%E5%88%99/</guid><description>路由反射器的反射规则：
1、反射器接收到EBGP邻居通告的BGP路由时候：当路由反射器接收到来自EBGP邻居通告的BGP路由，会把此路由同时通告给同一cluster内的client邻居，也通告给cluster之外的其他IBGP邻居。而路由中携带的Cluster list和Originator属性只发送给cluster内的client邻居。
2、反射器接收到cluster内的IBGP邻居发送来的路由时候：当路由反射器接收到同一cluster内的IBGP邻居发送来的BGP路由时候，反射器把该路由通告给cluster内其他所有client邻居，也通告给cluster外的其他IBGP邻居，这个通告的路由包括了Originator 属性和修改后的Cluster ID属性。如果该反射器存在EBGP邻居的话，反射器同时把该路由通告给所有的EBGP邻居，但不携带任何反射器相关属性。
3、反射器接收到cluster外的其他IBGP邻居发送的BGP路由时候：当反射器接收到cluster以外的其他IBGP邻居发送的路由时候，反射器会把该路由通告给自己cluster内所有的client邻居，添加合适的属性。如果该RR存在EBGP邻居的话，则RR同时也把该路由通告给自己所有的EBGP邻居，但不携带反射器相关属性。</description></item><item><title>运行时链接</title><link>https://www.ryken.cloud/%E8%BF%90%E8%A1%8C%E6%97%B6%E9%93%BE%E6%8E%A5/</link><pubDate>Wed, 26 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E8%BF%90%E8%A1%8C%E6%97%B6%E9%93%BE%E6%8E%A5/</guid><description>链接 现代连接器在处理动态库时将链接时路径（Link-time path）和运行时路径（Run-time path）分开，用户可以通过-L指定连接时库的路径，通过-R（或-rpath）指定程序运行时库的路径，大大提高了库应用的灵活性。
LIBRARY_PATH环境变量用于在程序编译期间查找动态链接库时指定查找共享库的路径 LD_LIBRARY_PATH环境变量用于在程序加载运行期间查找动态链接库时指定除了系统默认路径之外的其他路径，注意，LD_LIBRARY_PATH中指定的路径会在系统默认路径之前进行查找。
world.c
1 2 3 4 5 #include&amp;lt;stdio.h&amp;gt;void world(void) { printf(&amp;#34;world.\n&amp;#34;); } hello.</description></item><item><title/><link>https://www.ryken.cloud/hybridnet.excalidraw/</link><pubDate>Fri, 21 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/hybridnet.excalidraw/</guid><description>==⚠ Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠==
Text Elements leaf1 ^sDROrzpl
server1 ^eqxCtLQ4</description></item><item><title>calico配置文件</title><link>https://www.ryken.cloud/calico%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</link><pubDate>Thu, 20 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/calico%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</guid><description>cni 配置文件 1 kubectl get cm -n kube-system calico-config -o yaml 在安装 calico 时，configmap 中的特定参数会替换为 calico 定义的值，同时该 configmap 也会在 calico-daemonset 的 init 容器初始化时，被拷贝到 /etc/cni/net.</description></item><item><title>通过事件、日志排查</title><link>https://www.ryken.cloud/%E9%80%9A%E8%BF%87%E4%BA%8B%E4%BB%B6%E6%97%A5%E5%BF%97%E6%8E%92%E6%9F%A5/</link><pubDate>Thu, 20 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E9%80%9A%E8%BF%87%E4%BA%8B%E4%BB%B6%E6%97%A5%E5%BF%97%E6%8E%92%E6%9F%A5/</guid><description>BIRD is not ready: 输入命令：kubectl describe pods calico-node-xxx -n kube-system
1 2 3 4 5 6 7 8 9 10 Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal Scheduled 36m default-scheduler Successfully assigned kube-system/calico-node-xxx to worker1 Normal Pulled 36m kubelet Container image &amp;#34;calico/node:v3.</description></item><item><title>images-repository</title><link>https://www.ryken.cloud/images-repository/</link><pubDate>Thu, 13 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/images-repository/</guid><description>Moby = open source development Docker CE = free product release based on Moby Docker EE = commercial product release based on Docker CE.</description></item><item><title>multus-cni</title><link>https://www.ryken.cloud/multus-cni/</link><pubDate>Thu, 13 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/multus-cni/</guid><description>仓库地址： k8snetworkplumbingwg/multus-cni: A CNI meta-plugin for multi-homed pods in Kubernetes (github.com)
安装 kubectl apply -f https://raw.githubusercontent.com/k8snetworkplumbingwg/multus-cni/v3.9.2/deployments/multus-daemonset-thick-plugin.yml
使用 创建 NetworkAttachmentDefinition 资源 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 cat &amp;lt;&amp;lt;EOF | kubectl create -f - apiVersion: &amp;#34;k8s.</description></item><item><title>Network</title><link>https://www.ryken.cloud/Network/</link><pubDate>Thu, 13 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/Network/</guid><description>set [[路由反射器的反射规则]] [[BGP 环境搭建]] [[centos 配置网络文件]] [[linux 网络配置]] [[arp proxy]]</description></item><item><title>ssh</title><link>https://www.ryken.cloud/ssh/</link><pubDate>Thu, 13 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/ssh/</guid><description>1 2 3 4 5 WARNING: UNPROTECTED PRIVATE KEY FILE! Permissions 0777 for &amp;#39;/root/.ssh/id_rsa&amp;#39; are too open. It is recommended that your private key files are NOT accessible by others.</description></item><item><title/><link>https://www.ryken.cloud/%E7%BB%84%E4%BB%B6/</link><pubDate>Tue, 11 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E7%BB%84%E4%BB%B6/</guid><description>calico-node calico-controller
健康检查
ready live calico-node 容器以runit 作为进程管理工具，运行多个进程
进程树 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # ps -ef UID PID PPID C STIME TTY TIME CMD root 1 0 0 Jul28 ?</description></item><item><title>shell 常用</title><link>https://www.ryken.cloud/shell-%E5%B8%B8%E7%94%A8/</link><pubDate>Tue, 11 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/shell-%E5%B8%B8%E7%94%A8/</guid><description>#shell
移动光标 ctrl+a**: 移到行首（a是首字母）**
ctrl+e**: 移到行尾（end）**
ctrl+b: 前移一个字符(backward)
ctrl+f: 后移一个字符(forward)
alt+b: 前移一个单词</description></item><item><title>CloudNative</title><link>https://www.ryken.cloud/CloudNative/</link><pubDate>Mon, 10 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/CloudNative/</guid><description>1 2 list from &amp;#34;CloudNative&amp;#34; sort file.ctime</description></item><item><title>felix env</title><link>https://www.ryken.cloud/felix-env/</link><pubDate>Mon, 10 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/felix-env/</guid><description>日志：
FELIX_EARLYLOGSEVERITYSCREEN FELIX_LOGSEVERITYSCREEN go 垃圾回收
GOGC BPF 模式
KUBERNETES_SERVICE_HOST KUBERNETES_SERVICE_PORT 循环加载配置 - 直到 data store ready</description></item><item><title>FrequentlyUsed</title><link>https://www.ryken.cloud/FrequentlyUsed/</link><pubDate>Mon, 10 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/FrequentlyUsed/</guid><description>set [[build record]] [[shell 常用]] [[ssh]]</description></item><item><title>启动 startup</title><link>https://www.ryken.cloud/%E5%90%AF%E5%8A%A8-startup/</link><pubDate>Mon, 10 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E5%90%AF%E5%8A%A8-startup/</guid><description>startup 启动流程：
检测 ip 地址和 bgp 使用的网络 使用环境中提供的或自动检测到的 IP/AS 信息配置节点资源 创建默认的 ippool</description></item><item><title>官方提供插件</title><link>https://www.ryken.cloud/%E5%AE%98%E6%96%B9%E6%8F%90%E4%BE%9B%E6%8F%92%E4%BB%B6/</link><pubDate>Mon, 10 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E5%AE%98%E6%96%B9%E6%8F%90%E4%BE%9B%E6%8F%92%E4%BB%B6/</guid><description>macvlan 四种模式
vepa</description></item><item><title/><link>https://www.ryken.cloud/Arista-%E9%94%90%E6%8D%B7%E4%BA%A4%E6%8D%A2%E6%9C%BA%E9%85%8D%E7%BD%AE/</link><pubDate>Sat, 08 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/Arista-%E9%94%90%E6%8D%B7%E4%BA%A4%E6%8D%A2%E6%9C%BA%E9%85%8D%E7%BD%AE/</guid><description>#交换机 #arista
参考文档链接：
https://www.osslab.com.tw/wp-content/uploads/2018/03/Arista%E9%85%8D%E7%BD%AE%E6%89%8B%E5%86%8C.pdf https://www.arista.com/zh/um-eos/eos-ethernet-ports 登录：admin → enable → configure → zerotouch disable → write 先关闭zerotouch，否则会出现配置无法保存的情况 显示当前配置 show run</description></item><item><title/><link>https://www.ryken.cloud/calico-ebpf-dataplane/</link><pubDate>Sat, 08 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/calico-ebpf-dataplane/</guid><description>#calico #ebpf
介绍calico ebpf Introducing the Calico eBPF dataplane (tigera.io)
开启 calico ebpf Enable the eBPF dataplane (tigera.io)</description></item><item><title/><link>https://www.ryken.cloud/Calico-Full-Mesh-BGP-%E6%8A%A5%E6%96%87/</link><pubDate>Sat, 08 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/Calico-Full-Mesh-BGP-%E6%8A%A5%E6%96%87/</guid><description>#bgp #calico-bgp
集群环境 节点 ip 地址 角色 node1 172.30.10.2 master+worker node2 172.</description></item><item><title/><link>https://www.ryken.cloud/calico-iperf/</link><pubDate>Sat, 08 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/calico-iperf/</guid><description>calico 内部 node - node pod - pod （自身） pod - node（同） pod - node iperf3工具每100ms发一轮报文，每次在2、3ms内瞬间发完，iperf工具则均匀的发送报文，接口限速使用 iperf3 作为测试工具需要调整令牌桶参数以达到最佳效果。</description></item><item><title/><link>https://www.ryken.cloud/Calico-TOR-BGP-%E6%8A%A5%E6%96%87/</link><pubDate>Sat, 08 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/Calico-TOR-BGP-%E6%8A%A5%E6%96%87/</guid><description>#bgp #calico-bgp #calico
集群环境 节点 ip 地址 角色 node1 10.1.5.11 master+worker node2 10.</description></item><item><title/><link>https://www.ryken.cloud/calico-%E8%BF%90%E8%90%A5%E9%97%AE%E9%A2%98/</link><pubDate>Sat, 08 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/calico-%E8%BF%90%E8%90%A5%E9%97%AE%E9%A2%98/</guid><description>#calico #issue
配置etcd calico 支持两种数据存储，一种是使用 kubernetes api 接口来对其 etcd 进行读写操作；一种直接连接 etcd 进行读写操作，同时 calico 支持配置 etcd tls 进行数据加密实现安全的存储，对于 etcd 相关的证书生成以及更新维护不在 calico 管理范围之内。 docs/generate-self-signed-certificates.</description></item><item><title/><link>https://www.ryken.cloud/conntrack/</link><pubDate>Sat, 08 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/conntrack/</guid><description>查看、加载、卸载 nf_conntrack 模块
连接跟踪（conntrack）：原理、应用及 Linux 内核实现 摘要 本文介绍连接跟踪（connection tracking，conntrack，CT）的原理，应用，及其在 Linux 内核中的实现。
代码分析基于内核 4.19。为使行文简洁，所贴代码只保留了核心逻辑，但都给出了代码 所在的源文件，如有需要请查阅。
水平有限，文中不免有错误之处，欢迎指正交流。
1 引言 连接跟踪是许多网络应用的基础。例如，Kubernetes Service、ServiceMesh sidecar、 软件四层负载均衡器 LVS/IPVS、Docker network、OVS、iptables 主机防火墙等等，都依赖 连接跟踪功能。</description></item><item><title/><link>https://www.ryken.cloud/containerlab/</link><pubDate>Sat, 08 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/containerlab/</guid><description>#containerlab #network #tools
安装 bash -c &amp;ldquo;$(curl -sL https://get.containerlab.dev)&amp;rdquo;
配置 vyos
网络模式
主机网络 容器网络 配置 spine + leaf 安装 docker、kubectl</description></item><item><title/><link>https://www.ryken.cloud/felix/</link><pubDate>Sat, 08 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/felix/</guid><description>felix 主要的工作组件：syncer, CalcGraph, dataplane
Syncer 协程负责监听 datastore 中的更新，并将更新的内容通过 channel 发送给 Validator 协程。Validator 完成校验后，将其发送给 Calc graph 协程。Calc graph 完成计算后，发送给dataplane协程。最后dataplane完成数据平面处理。 syncer, calicoctl 可以直接向 datastore 增删改查一系列 Resource。syncer 同步且监听这些Resource，当资源变动时，通过回调onUpdate 通知下游组件（比如CalcGraph）。 CalcGraph, syncer 传递的 datastore 数据通常不能直接使用，需要CalcGraph 做一些计算和归并再交给dataplane dataplane 负责对 node 做出处理。 dataplane 分为本地和远程两种形态，如果是本地运行，则通过channel 直接传输 proto model，如果是dataplane 远程独立运行，则执行grpc 调用； github.</description></item><item><title/><link>https://www.ryken.cloud/fortio-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/</link><pubDate>Sat, 08 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/fortio-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/</guid><description/></item><item><title/><link>https://www.ryken.cloud/hybirdnet-%E4%BD%BF%E7%94%A8/</link><pubDate>Sat, 08 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/hybirdnet-%E4%BD%BF%E7%94%A8/</guid><description>#hybridnet #cni
[[hybirdnet.svg]] 给节点打 label
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 apiVersion:networking.</description></item><item><title/><link>https://www.ryken.cloud/hybirdnet-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</link><pubDate>Sat, 08 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/hybirdnet-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</guid><description>#hybridnet
crd 资源定义解释 [[hybridnet 自定义资源解释]] 整个流程：kubelet -&amp;gt; cni -&amp;gt; 打通网络 ipam 如何处理 环境的搭建 overlay 模式实现原理 封装的网卡 路由 创建的资源</description></item><item><title/><link>https://www.ryken.cloud/iptables/</link><pubDate>Sat, 08 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/iptables/</guid><description>#iptables #calico
Calico 使用 iptables 数据面时会创建多个 iptables 规则来实现网络策略和流量控制。这些规则用于实现诸如流量隔离、流量转发、负载均衡和访问控制等功能。 Calico 会根据定义的网络策略自动生成 iptables 规则。此外，Calico 还会创建一些基础规则来实现其核心功能，例如路由和网络隔离。所以说，即使您没有定义任何网络策略，Calico 仍然会在主机上创建一些 iptables 规则。
calico 使用 iptables
与 service 有什么关系？</description></item><item><title/><link>https://www.ryken.cloud/kube-ovn-underlay/</link><pubDate>Sat, 08 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/kube-ovn-underlay/</guid><description>#kube-ovn #underlay
功能限制 由于该模式下容器网络直接使用物理网络进行二层包转发，Overlay 模式下的 SNAT/EIP， 分布式网关/集中式网关等 L3 功能无法使用。
使用 underlay 模式主要涉及的资源有：
资源 说明 provider-networks underlay 网卡提供者 vlans vlan 信息 subnets 子网/ippool 地址池 ips ip 分配记录 provider-networks 资源 ProviderNetwork 提供了主机网卡到物理网络映射的抽象，将同属一个网络的网卡进行统一管理， 并解决在复杂环境下同机器多网卡、网卡名不一致、对应 Underlay 网络不一致等情况下的配置问题。</description></item><item><title/><link>https://www.ryken.cloud/RSS-RPS/</link><pubDate>Sat, 08 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/RSS-RPS/</guid><description>单队列没有问题，多队列有问题 ebpf
网卡多队列 多核 多CPU RSS RPS RFS
由于这块内存区域是有限的，如果数据包的速率非常快，单个 CPU 来不及取走这些包，新来的包就会被丢弃。这时候，Receive Side Scaling（RSS，接收端扩展）或者多队列（multiqueue）一类的技术可能就会排上用场。
可以把软中断系统想象成一系列内核线程（每个 CPU 一个），这些线程执行针对不同事件注册的处理函数（handler）。如果你执行过 top 命令，可能会注意到ksoftirqd/0 这个内核线程，其表示这个软中断线程跑在 CPU 0 上。</description></item><item><title/><link>https://www.ryken.cloud/wireshark-%E6%8A%93%E5%8C%85/</link><pubDate>Sat, 08 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/wireshark-%E6%8A%93%E5%8C%85/</guid><description>#wireshark #抓包
wireshark 抓远程 ubuntu 的包 安装 rpcapd rpcapd 是一个为 Windows 版本的Wireshark协议分析器提供远程流量捕获的守护进程。它随Windows 的 WinPcap 网络捕获库一起提供，之前 Linux 中的没有 libpcap ,后来添加了。 使用 rpcapd-linux 使用 the-tcpdump-group/libpcap 【推荐】没有大的报错问题 1 2 3 4 5 6 apt-get build-dep libpcap -y git clone https://github.</description></item><item><title/><link>https://www.ryken.cloud/%E5%85%89%E5%A4%A7-calico-bgp-%E6%96%AD%E8%81%94%E5%8E%9F%E5%9B%A0/</link><pubDate>Sat, 08 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E5%85%89%E5%A4%A7-calico-bgp-%E6%96%AD%E8%81%94%E5%8E%9F%E5%9B%A0/</guid><description>背景 + 分析 行内在进行 http 短连接性能测试时，calico 意外重启，而 calico 重启导致了节点与交换机 bgp 断连，触发行内交换机监控告警。 重启时查看之前容器日志发现并没有明显的错误日志，查看系统日志发现同一时间段 kubelet 探针超时失败，并且也有其他 pod 发生重启的日志。 由于是针对与网络的测试，所有分析并提出以下解决方案： 排查路由数量 对于路由聚合
交换机侧：先讨论交换机上可行性，但因为两会期间，行内封网无法进行交换机配置的改动，没有进行尝试 bird 配置：临时修改了 calico bird 配置（进入 docker merge 读写层修改 bird 配置文件，并手动创建/删除 ippool，让 confd 重新刷新配置并生效，注意重启 calico 后，bird 配置会复原），让其只导入集群相关的路由，将路由数量由5600多减少到 100 左右。 减少路由后测试，calico 仍然会触发重启，排除路由数量的因素。</description></item><item><title/><link>https://www.ryken.cloud/%E5%86%85%E6%A0%B8%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0/</link><pubDate>Sat, 08 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E5%86%85%E6%A0%B8%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0/</guid><description/></item><item><title/><link>https://www.ryken.cloud/%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF/</link><pubDate>Sat, 08 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF/</guid><description>#开机自启 #linux
最简单的方法是使用 rc.local 实现开机自启，不过由于系统版本更替，很多新版本都没有 rc.local 文件了，需要手动设置 添加 /etc/rc.local 文件
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 cat &amp;lt;&amp;lt;EOF &amp;gt;/etc/rc.</description></item><item><title/><link>https://www.ryken.cloud/%E6%A8%A1%E5%9D%97%E4%BB%A5%E5%8F%8A%E9%85%8D%E7%BD%AE/</link><pubDate>Sat, 08 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E6%A8%A1%E5%9D%97%E4%BB%A5%E5%8F%8A%E9%85%8D%E7%BD%AE/</guid><description>#blockbox #exporter #prometheus
简单介绍 Blackbox Exporter 是 Prometheus 社区提供的 官方黑盒监控解决方案,其允许用户通过: http\HTTPS\DNS\TCP\ICMP\gRPC的方式对网络进行探测.
支持的协议：HTTP, HTTPS, DNS, TCP, ICMP, gRPC.
各个模块的配置： blackbox_exporter/CONFIGURATION.md at master · prometheus/blackbox_exporter (github.</description></item><item><title/><link>https://www.ryken.cloud/%E6%B5%81%E9%87%8F%E8%B5%B0%E5%90%91/</link><pubDate>Sat, 08 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E6%B5%81%E9%87%8F%E8%B5%B0%E5%90%91/</guid><description/></item><item><title/><link>https://www.ryken.cloud/%E7%BD%91%E5%8D%A1%E5%A4%9A%E9%98%9F%E5%88%97-+-%E4%B8%AD%E6%96%AD%E7%BB%91%E5%AE%9A/</link><pubDate>Sat, 08 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E7%BD%91%E5%8D%A1%E5%A4%9A%E9%98%9F%E5%88%97-+-%E4%B8%AD%E6%96%AD%E7%BB%91%E5%AE%9A/</guid><description>#网卡多队列 #network #irqbalance
单CPU处理网络IO存在瓶颈, 目前经常使用网卡多队列提高性能.
通常情况下, 每张网卡有一个队列(queue), 所有收到的包从这个队列入, 内核从这个队列里取数据处理. 该队列其实是ring buffer(环形队列), 内核如果取数据不及时, 则会存在丢包的情况.
一个CPU处理一个队列的数据, 这个叫中断. 默认是cpu0(第一个CPU)处理. 一旦流量特别大, 这个CPU负载很高, 性能存在瓶颈. 所以网卡开发了多队列功能, 即一个网卡有多个队列, 收到的包根据TCP四元组信息hash后放入其中一个队列, 后面该链接的所有包都放入该队列.</description></item><item><title/><link>https://www.ryken.cloud/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</link><pubDate>Sat, 08 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</guid><description>#calico #calico-config
confd /etc/calico/conf/config
修改 mtu kubectl edit configmap/calico-config -n kube-system
问题：
能否修改 confd 的配置，实现修改 calico bird 参数的目的</description></item><item><title/><link>https://www.ryken.cloud/4.1-%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/4.1-%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D/</guid><description/></item><item><title/><link>https://www.ryken.cloud/4.2-%E7%AC%A6%E5%8F%B7%E8%A7%A3%E6%9E%90%E4%B8%8E%E9%87%8D%E5%AE%9A%E4%BD%8D/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/4.2-%E7%AC%A6%E5%8F%B7%E8%A7%A3%E6%9E%90%E4%B8%8E%E9%87%8D%E5%AE%9A%E4%BD%8D/</guid><description/></item><item><title/><link>https://www.ryken.cloud/4.3-COMMON%E5%9D%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/4.3-COMMON%E5%9D%97/</guid><description/></item><item><title/><link>https://www.ryken.cloud/4.4-C++%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/4.4-C++%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</guid><description/></item><item><title/><link>https://www.ryken.cloud/4.5-%E9%9D%99%E6%80%81%E5%BA%93%E9%93%BE%E6%8E%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/4.5-%E9%9D%99%E6%80%81%E5%BA%93%E9%93%BE%E6%8E%A5/</guid><description/></item><item><title/><link>https://www.ryken.cloud/4.6-%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B%E6%8E%A7%E5%88%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/4.6-%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B%E6%8E%A7%E5%88%B6/</guid><description/></item><item><title/><link>https://www.ryken.cloud/4.7-BFD%E5%BA%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/4.7-BFD%E5%BA%93/</guid><description/></item><item><title/><link>https://www.ryken.cloud/BGP-%E6%8A%A5%E6%96%87/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/BGP-%E6%8A%A5%E6%96%87/</guid><description>#bgp #bird bird文档 labs / BIRD Internet Routing Daemon · GitLab (nic.cz)
bgp 报文类型
type 报文类型 用途 1 Open 建立 BGP 连接 2 Update 用于通告路由 3 Notification 用于处理 BGP 进程中的各种错误 4 Keepalive 用于保持 BGP 连接 5 Refresh 用于动态的请求 BGP 路由发布者重新发布 Update 报文，进行路由更新 配置 tor 为 Route Reflector 以及选取集群中一个节点作为 Route Reflector 的区别 RR是一种用于提高BGP网络中路由传播效率的技术。在 BGP 网络中，每个节点通常需要向其邻居节点发送完整的路由表，这可能会导致网络带宽消耗和延迟增加。通过使用 RR，节点可以将路由信息发送到 RR 节点，RR 节点然后将其转发给其他节点，从而减少了网络流量和节点负担。</description></item><item><title/><link>https://www.ryken.cloud/BGP-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.excalidraw/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/BGP-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.excalidraw/</guid><description>==⚠ Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠==
Text Elements spine1 ^ysTSUxD3
spine2 ^NLhMxLIF</description></item><item><title/><link>https://www.ryken.cloud/BIRD-%E6%96%87%E6%A1%A3-+-%E9%A1%B9%E7%9B%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/BIRD-%E6%96%87%E6%A1%A3-+-%E9%A1%B9%E7%9B%AE/</guid><description>#bird
文档： The BIRD Internet Routing Daemon Project (network.cz) 项目地址： Files · master · labs / BIRD Internet Routing Daemon · GitLab (nic.</description></item><item><title/><link>https://www.ryken.cloud/calico/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/calico/</guid><description>[[基本使用]]</description></item><item><title/><link>https://www.ryken.cloud/cEOS-%E9%85%8D%E7%BD%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/cEOS-%E9%85%8D%E7%BD%AE/</guid><description>#containerlab #cEOS #交换机
锐捷交换机
enable configure show running-config
vlan 10~12 interface vlan 10 ip address 10.10.10.1 255.255.255.0
interface Ethernet 2 switchport mode trunk switchport trunk native vlan 10 switchport trunk allowed vlan remove 1-4094 Switchport trunk allow vlan add 10,11,12</description></item><item><title/><link>https://www.ryken.cloud/confd-%E7%BB%84%E4%BB%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/confd-%E7%BB%84%E4%BB%B6/</guid><description>开源的、轻量级的配置管理工具。监控Calico数据存储对BGP配置和全局默认的日志变更，如AS号、日志级别和IPAM信息。
Confd根据存储中的数据更新，动态生成BIRD配置文件。当配置文件发生变化时，confd会触发BIRD加载新的文件。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 function apply_communities (){{{- $prefix_advertisements_key := &amp;#34;&amp;#34;}}{{- $node_prefix_advertisements_key := printf &amp;#34;/host/%s/prefix_advertisements/ip_v4&amp;#34; (getenv &amp;#34;NODENAME&amp;#34;)}}{{- if exists $node_prefix_advertisements_key}}{{- $prefix_advertisements_key = $node_prefix_advertisements_key}}{{- else if exists &amp;#34;/global/prefix_advertisements/ip_v4&amp;#34;}}{{- $prefix_advertisements_key = &amp;#34;/global/prefix_advertisements/ip_v4&amp;#34;}}{{- end}}{{- if ne &amp;#34;&amp;#34; $prefix_advertisements_key}}{{- range gets $prefix_advertisements_key}}{{- $arr:= jsonArray .</description></item><item><title/><link>https://www.ryken.cloud/ebpf-%E6%8E%92%E6%9F%A5%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/ebpf-%E6%8E%92%E6%9F%A5%E5%B7%A5%E5%85%B7/</guid><description>排查工具：ftrace / bcc trace 问题排查利器：Linux 原生跟踪工具 Ftrace 必知必会 | 深入浅出 eBPF</description></item><item><title/><link>https://www.ryken.cloud/encoding_gob/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/encoding_gob/</guid><description/></item><item><title/><link>https://www.ryken.cloud/encoding_json/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/encoding_json/</guid><description/></item><item><title/><link>https://www.ryken.cloud/encoding%E5%BA%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/encoding%E5%BA%93/</guid><description/></item><item><title/><link>https://www.ryken.cloud/felix-%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/felix-%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/</guid><description>#calico-felix #calico-ebpf
入口处：felix/dataplane/linux/int_dataplane.go 的 NewIntDataplaneDriver() 函数，进行dataplane的初始化 首先会判断是否开启了BPF，如果是开启状态，则进行以下操作： 1）注册 map manager，该manager的作用是负责管理ebpf的map（map用于userspace和kernel之间进行数据的共享） 2）注册endpoint manager，该manager的作用是负责各种ep的管理，包括host、workload等 3）创建各种map，比如nat的frontendMap、backendMap、routeMap、conntrackMap等 4）开启kube-proxy，注意此kube-proxy并非kubernetes的kube-proxy，而是proxy的一个封装，负责和kubernetes通信，维护各种map中的信息 5）若BPFConnTimeEnabled开启，则安装connect_time_loadbalancer，即加载相关的eBPF程序 6）启动dataplane（这部分暂不涉及connect_time_loadbalancer，本文暂不分析）
calico 全部的组件以及其进程树详见：[[组件]] felix 组件 [[felix]]</description></item><item><title/><link>https://www.ryken.cloud/Flannel-%E7%BD%91%E7%BB%9C%E6%8F%92%E4%BB%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/Flannel-%E7%BD%91%E7%BB%9C%E6%8F%92%E4%BB%B6/</guid><description>#flannel #cni</description></item><item><title/><link>https://www.ryken.cloud/go-interface/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/go-interface/</guid><description/></item><item><title/><link>https://www.ryken.cloud/go-%E5%B9%B6%E5%8F%91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/go-%E5%B9%B6%E5%8F%91/</guid><description/></item><item><title/><link>https://www.ryken.cloud/go-%E7%B1%BB%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/go-%E7%B1%BB%E5%9E%8B/</guid><description>值类型给编译器提供规模和表示两部分 当声明变量时，这个变量对应的值总是会被初始化。这个值要么用指定的值初始化，要么用零值（即变量类型的默认值）做初始化。对数值类型来说，零值是 0；对字符串来说，零值是空字符串；对布尔类型，零值是 false。对这个例子里的结构，结构里每个字段都会用零值初始化。
1 2 3 4 5 6 7 8 9 10 11 package main type Duration int64 func main() { var dur Duration dur = int64(1000) } // # command-line-arguments // .</description></item><item><title/><link>https://www.ryken.cloud/go-%E8%B0%83%E5%BA%A6%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/go-%E8%B0%83%E5%BA%A6%E5%99%A8/</guid><description/></item><item><title/><link>https://www.ryken.cloud/golang-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/golang-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</guid><description/></item><item><title/><link>https://www.ryken.cloud/goroutine-%E5%8D%8F%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/goroutine-%E5%8D%8F%E7%A8%8B/</guid><description/></item><item><title/><link>https://www.ryken.cloud/H3C-0519x64/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/H3C-0519x64/</guid><description>#交换机 #h3c
文档链接：
H3C VSR系列虚拟路由器 配置指导-E0518-5W101_三层技术-IP路由配置指导_BGP配置-新华三集团-H3C 连接公网ip 配置基础网络网卡ip 1 2 interface ge3/0 ip address 10.</description></item><item><title/><link>https://www.ryken.cloud/helm-Tools/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/helm-Tools/</guid><description>#helm
1. 官网地址 https://helm.sh/
2. 在ubuntu上安装 1 2 3 4 5 curl https://baltocdn.com/helm/signing.asc | sudo apt-key add - sudo apt-get install apt-transport-https --yes echo &amp;#34;deb https://baltocdn.</description></item><item><title/><link>https://www.ryken.cloud/icmp-tcp-dns-%E9%85%8D%E7%BD%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/icmp-tcp-dns-%E9%85%8D%E7%BD%AE/</guid><description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 ---apiVersion:v1kind:Namespacemetadata:name:monitoring-systemlabels:app:monitoring---apiVersion:v1kind:ConfigMapmetadata:name:blackbox-confignamespace:monitoring-systemdata:blackbox.</description></item><item><title/><link>https://www.ryken.cloud/install-KubeOVN/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/install-KubeOVN/</guid><description>#kube-ovn #kubekey #install
overlay 安装 使用 kubekey 安装 1 2 3 4 5 6 7 8 9 10 11 apiVersion:kubekey.</description></item><item><title/><link>https://www.ryken.cloud/iptables-%E8%BD%AC%E5%8F%91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/iptables-%E8%BD%AC%E5%8F%91/</guid><description>#iptables
端口转发 将本机的8080端口转发至其他主机，主机IP：192.168.1.12，目标主机IP和端口：192.168.1.13:8088，规则如下
1 2 3 iptables -t nat -A PREROUTING -p tcp -m tcp --dport 8080 -j DNAT --to-destination 192.</description></item><item><title/><link>https://www.ryken.cloud/IPV6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/IPV6/</guid><description>#ipv6 #calico
参考文档：
IPv4/IPv6 双协议栈 | Kubernetes Configure dual stack or IPv6 only | Calico Documentation (tigera.io) 配置 kubernetes kube-apiserver: --service-cluster-ip-range=&amp;lt;IPv4 CIDR&amp;gt;,&amp;lt;IPv6 CIDR&amp;gt; kube-controller-manager: --cluster-cidr=&amp;lt;IPv4 CIDR&amp;gt;,&amp;lt;IPv6 CIDR&amp;gt; --service-cluster-ip-range=&amp;lt;IPv4 CIDR&amp;gt;,&amp;lt;IPv6 CIDR&amp;gt; --node-cidr-mask-size-ipv4|--node-cidr-mask-size-ipv6 对于 IPv4 默认为 /24， 对于 IPv6 默认为 /64 kube-proxy: --cluster-cidr=&amp;lt;IPv4 CIDR&amp;gt;,&amp;lt;IPv6 CIDR&amp;gt; kubelet: 当没有 --cloud-provider 时，管理员可以通过 --node-ip 来传递逗号分隔的 IP 地址， 为该节点手动配置双栈 .</description></item><item><title/><link>https://www.ryken.cloud/k9s-Tools/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/k9s-Tools/</guid><description>#k9s
release url: Releases · derailed/k9s (github.com)
安装
配置： derailed/k9s: 🐶 Kubernetes CLI To Manage Your Clusters In Style! (github.com) ~/.</description></item><item><title/><link>https://www.ryken.cloud/Kind-Tools/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/Kind-Tools/</guid><description>#kind #install
文档： https://kind.sigs.k8s.io/docs/user/quick-start
安装二进制 1 2 3 curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.16.0/kind-linux-amd64 chmod +x ./kind sudo mv .</description></item><item><title/><link>https://www.ryken.cloud/kube-ovn-ipam/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/kube-ovn-ipam/</guid><description>#ipam #kube-ovn
ip 分配 随机分配 对于工作负载的 ip 分配策略
优先使用负载指定的：ovn.kubernetes.io/logical_switch: subnet 如果负载没有指定使用，使用 namespace 绑定的 subnet 如果 namespace 没有绑定 subnet，使用安装默认的 ovn-default 静态分配 静态分配即在 pod 的 annotations 中添加对应的注解：如果 mac 地址为空，会随机申请出一个 mac 地址。</description></item><item><title/><link>https://www.ryken.cloud/kube-ovn-networkpolicy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/kube-ovn-networkpolicy/</guid><description>#network-policy #kube-ovn
标准的 NetworkPolicy kube-ovn 支持标准的 NetworkPolicy，但是无法作用于 node 上的策略
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 apiVersion:networking.</description></item><item><title/><link>https://www.ryken.cloud/kube-ovn-overlay-vpc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/kube-ovn-overlay-vpc/</guid><description>#cni #kube-ovn #overlay
overlay 模式路由网络打通 Overlay 下路由方式网络打通 - Kube-OVN 文档
网关类型 仅在默认 vpc 下支持，子网管理
分布式网关 子网的默认类型网关，每个 node 会作为当前 node 上 pod 访问外部网络的网关。数据包会通过本机的 ovn0 网卡流入主机网络栈，再根据主机的路由规则进行出网。 当 natOutgoing 为 true 时，Pod 访问外部网络将会使用当前所在宿主机的 IP。</description></item><item><title/><link>https://www.ryken.cloud/kube-ovn/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/kube-ovn/</guid><description>#kube-ovn #cni
文档链接： Kube-OVN 文档 发布版本： Releases · kubeovn/kube-ovn (github.com)
kube-ovn 1.9 版本自定义资源
自定义资源 说明 备注 vpcs 自定义vpc vpc-nat-gateways vpc 出口网关 subnets 子网/ippool 地址池 provider-networks underlay 网卡提供者 vlans vlan 信息 ips ip 分配记录 htbqoses pod 网络限速 security-groups 安全组信息 kube-ovn 1.</description></item><item><title/><link>https://www.ryken.cloud/kube-proxy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/kube-proxy/</guid><description>使用模式：ipvs or iptables
切换方式
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 ~#: kubectl -n kube-system edit cm kube-proxy apiVersion: v1 data: config.</description></item><item><title/><link>https://www.ryken.cloud/kubectl-ko/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/kubectl-ko/</guid><description>#kube-ovn #kubectl
有时候安装完成 kube-ovn 之后，kubectl ko 插件无法使用</description></item><item><title/><link>https://www.ryken.cloud/markdown-style/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/markdown-style/</guid><description>#markdown
Extended Syntax | Markdown Guide</description></item><item><title/><link>https://www.ryken.cloud/net_http/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/net_http/</guid><description/></item><item><title/><link>https://www.ryken.cloud/net_http_cgi/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/net_http_cgi/</guid><description/></item><item><title/><link>https://www.ryken.cloud/net_http_cookiejar/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/net_http_cookiejar/</guid><description/></item><item><title/><link>https://www.ryken.cloud/net_rpc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/net_rpc/</guid><description/></item><item><title/><link>https://www.ryken.cloud/netlab/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/netlab/</guid><description>#netlab
项目地址： ipspace/netlab: Making virtual networking labs suck less (github.com)
文档地址： VLANs — Network Simulation Tools documentation (netsim-tools.readthedocs.io)
别人的一个 demo： netlab Simple VLAN Example « ipSpace.</description></item><item><title/><link>https://www.ryken.cloud/network-tools/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/network-tools/</guid><description>#nsenter
nsenter -u -n -t $pid bash
nsenter --uts --net --target 3326 --ipc --mount --pid
网卡队列设置为1 + 网卡终端绑定至 CPU0 [Linux 性能调优] 网卡中断与CPU的绑定问题 - 巴蛮子 - 博客园 (cnblogs.</description></item><item><title/><link>https://www.ryken.cloud/ss-%E5%91%BD%E4%BB%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/ss-%E5%91%BD%E4%BB%A4/</guid><description>#network #tool
ss 命令用于显示socket状态. 他可以显示PACKET sockets, TCP sockets, UDP sockets, DCCP sockets, RAW sockets, Unix domain sockets等等统计. 它比其他工具展示等多tcp和state信息. 它是一个非常实用、快速、有效的跟踪IP连接和sockets的新工具.
功能类似：netstat</description></item><item><title/><link>https://www.ryken.cloud/tc-tbf/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/tc-tbf/</guid><description>tbf - token bucket Filter 令牌桶过滤器
tbf sfq 无类算法 流量控制 TBF 队列控制 SFQ 随机公平队列
分类算法：PRIO/CBQ/HTB 对多种数据流区别对待
PRIO：分类优先算法 (从左至右优先发包), 队列规定并不进行整形，它仅仅根据配置的过滤器把流量进一步细分 CBQ：工作机制是确认链路的闲置时间足够长，以达到降低链路实际带宽的目的 HTB：分层的令牌桶一个分类的令牌桶过滤器 linux 流量控制：</description></item><item><title/><link>https://www.ryken.cloud/tcpdump/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/tcpdump/</guid><description>tcpdump -i any -w mycap.pacp</description></item><item><title/><link>https://www.ryken.cloud/termshark/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/termshark/</guid><description>#wireshark #tcpdump #termshark
安装： Releases · gcla/termshark (github.com)</description></item><item><title/><link>https://www.ryken.cloud/use-kube-ovn/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/use-kube-ovn/</guid><description>#kube-ovn #cni #how-to-use
核心资源 subnet
示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 apiVersion:kubeovn.</description></item><item><title/><link>https://www.ryken.cloud/vyos-OSPF-%E9%85%8D%E7%BD%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/vyos-OSPF-%E9%85%8D%E7%BD%AE/</guid><description>#vyos #路由器
1 2 3 4 5 6 set interfaces loopback lo address 9.9.9.9/32 set protocols ospf parameters router-id 8.</description></item><item><title/><link>https://www.ryken.cloud/wireshark-%E6%8A%93%E5%8C%85%E8%BF%87%E6%BB%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/wireshark-%E6%8A%93%E5%8C%85%E8%BF%87%E6%BB%A4/</guid><description>#wireshark
功能 表达式 筛选特定 ip ip.addr == xxx</description></item><item><title/><link>https://www.ryken.cloud/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9B%B8%E5%85%B3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9B%B8%E5%85%B3/</guid><description>#containerlab #交换机
Nokia SR Linux
1 2 3 4 5 # access CLI docker exec -it &amp;lt;name&amp;gt; sr_cli # access bash docker exec -it &amp;lt;name&amp;gt; bash Arista cEOS</description></item><item><title/><link>https://www.ryken.cloud/%E4%BD%BF%E7%94%A8code-generator%E7%94%9F%E6%88%90crd%E7%9A%84clientsetinformerlisters/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E4%BD%BF%E7%94%A8code-generator%E7%94%9F%E6%88%90crd%E7%9A%84clientsetinformerlisters/</guid><description>#code-generator #informer #kubernetes #kubebuilder
参考链接： 使用code-generator生成crd的clientset、informer、listers - 赶路人的博客 (xieys.club)</description></item><item><title/><link>https://www.ryken.cloud/%E5%85%AC%E6%9C%89%E4%BA%91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E5%85%AC%E6%9C%89%E4%BA%91/</guid><description>https://cwiki.yunify.com/pages/viewpage.action?pageId=23659614&amp;src=contextnavpagetreemode
https://cwiki.yunify.com/pages/viewpage.action?pageId=96318071&amp;src=contextnavpagetreemode
yunify/qingcloud-cloud-controller-manager: A kubernetes cloud-controller-manager for the qingcloud (github.com)</description></item><item><title/><link>https://www.ryken.cloud/%E5%88%9D%E5%A7%8Bnginx/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E5%88%9D%E5%A7%8Bnginx/</guid><description/></item><item><title/><link>https://www.ryken.cloud/%E5%89%96%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E5%89%96%E6%9E%90/</guid><description>Calico eBPF Data Plane Deep-Dive (tigera.io)
nodeport 流量到来之后如何处理的
host ip update ？
kube-proxy ： 用于处理高级的问题，如重启、配置等</description></item><item><title/><link>https://www.ryken.cloud/%E5%8F%8C%E6%A0%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E5%8F%8C%E6%A0%88/</guid><description>kubekey 开发需求 检测主机是否支持 ipv6 修正 ipv6 相关的内核参数 支持开启 ipv6 以及 ipv6 的配置项（编辑 cni 配置文件） 安装 calico 并开启 ipv6 （添加 calico-node daemonset 的 ipv6 相关的环境变量） 配置 ipv6 (添加默认的 ipv6 ippool) 初始化 kubernetes 需要开启 ipv6 (使用 kubeadm 配置 kube-apiserver、kube-controller-manager、kube-proxy、kubelet 来开启 ipv6) ks 内部组件开发需求 ks 内部组件 ippool 支持 ipv6</description></item><item><title/><link>https://www.ryken.cloud/%E6%89%8B%E5%8A%A8%E5%88%9B%E5%BB%BA-netns-+-%E8%B7%A8%E4%B8%BB%E6%9C%BA%E9%80%9A%E4%BF%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E6%89%8B%E5%8A%A8%E5%88%9B%E5%BB%BA-netns-+-%E8%B7%A8%E4%B8%BB%E6%9C%BA%E9%80%9A%E4%BF%A1/</guid><description>#network #netns
使用 arp-proxy，并在主机上添加对应的路由联通 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 # echo 1 &amp;gt; /proc/sys/net/ipv4/ip_forward echo &amp;#39;net.</description></item><item><title/><link>https://www.ryken.cloud/%E6%8E%92%E6%9F%A5-calico-ebpf/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E6%8E%92%E6%9F%A5-calico-ebpf/</guid><description>#calico #ebpf
配置 kube-proxy
1 2 3 4 5 kubectl patch ds -n kube-system kube-proxy -p &amp;#39;{&amp;#34;spec&amp;#34;:{&amp;#34;template&amp;#34;:{&amp;#34;spec&amp;#34;:{&amp;#34;nodeSelector&amp;#34;:{&amp;#34;non-calico&amp;#34;: &amp;#34;true&amp;#34;}}}}}&amp;#39; kubectl patch felixconfiguration default --type merge --patch=&amp;#39;{&amp;#34;spec&amp;#34;: {&amp;#34;bpfEnabled&amp;#34;: true}}&amp;#39; # 如果无法禁用 kube-proxy ，配置 Felix kubectl patch felixconfiguration default --type merge --patch=&amp;#39;{&amp;#34;spec&amp;#34;: {&amp;#34;bpfKubeProxyIptablesCleanupEnabled&amp;#34;: false}}&amp;#39; 取消设置 - 回滚</description></item><item><title/><link>https://www.ryken.cloud/%E6%97%B6%E5%8C%BA-%E5%90%8C%E6%AD%A5%E6%97%B6%E9%97%B4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E6%97%B6%E5%8C%BA-%E5%90%8C%E6%AD%A5%E6%97%B6%E9%97%B4/</guid><description>查看系统时区 timedatectl
修改系统时区 1 2 3 4 timedatectl list-timezones | grep -i shang Asia/Shanghai timedatectl set-timezone Asia/Shanghai 软连接修改时区 1 2 3 4 5 ```shell root@node1:~#ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime root@node1:~# ls -l /etc/localtime lrwxrwxrwx 1 root root 33 May 20 2022 /etc/localtime -&amp;gt; /usr/share/zoneinfo/Asia/Shanghai</description></item><item><title/><link>https://www.ryken.cloud/%E6%9C%AA%E5%91%BD%E5%90%8D/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E6%9C%AA%E5%91%BD%E5%90%8D/</guid><description>#loadbalance
| 名称 | 解释 | 层级|= |&amp;ndash;|&amp;ndash;|&amp;ndash;| |DLB | DNS 负载均衡 | 七层 | | ALB | Application 负载均衡 | 七层 | | NLB | Network 负载均衡 | 四层 |</description></item><item><title/><link>https://www.ryken.cloud/%E6%9F%A5%E7%9C%8B-CPU%E5%86%85%E5%AD%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E6%9F%A5%E7%9C%8B-CPU%E5%86%85%E5%AD%98/</guid><description>查看 cpu 信息： cat /proc/cpuinfo
1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 总核数 = 物理CPU个数 X 每颗物理CPU的核数 # 总逻辑CPU数 = 物理CPU个数 X 每颗物理CPU的核数 X 超线程数 # 查看物理CPU个数 cat /proc/cpuinfo| grep &amp;#34;physical id&amp;#34;| sort| uniq| wc -l # 查看每个物理CPU中core的个数(即核数) cat /proc/cpuinfo| grep &amp;#34;cpu cores&amp;#34;| uniq # 查看逻辑CPU的个数 cat /proc/cpuinfo| grep &amp;#34;processor&amp;#34;| wc -l # 查看CPU信息（型号） cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c 查看 mem 信息： cat /proc/meminfo</description></item><item><title/><link>https://www.ryken.cloud/%E7%BB%84%E7%BD%91.excalidraw/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E7%BB%84%E7%BD%91.excalidraw/</guid><description>==⚠ Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠==
Text Elements 45.120.216.46 ^ZNmnY1tc
192.168.0.1 ^8cHK23kk</description></item><item><title/><link>https://www.ryken.cloud/%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8/</guid><description>#kubernetes #tools
安装 bash-completion 应用 kubectl 的 completion 1 2 source &amp;lt;(kubectl completion bash) echo &amp;#34;source &amp;lt;(kubectl completion bash)&amp;#34; &amp;gt;&amp;gt; ~/.</description></item><item><title/><link>https://www.ryken.cloud/%E8%B5%84%E6%BA%90%E7%B1%BB%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E8%B5%84%E6%BA%90%E7%B1%BB%E5%9E%8B/</guid><description>#spider-pool #cni
没有默认路由 导致无法连接 kubernetes.default</description></item><item><title/><link>https://www.ryken.cloud/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/</guid><description>#kube-ovn
kube-ovn 实现跨主机通信的原理 在 泰山服务器、华为鲲鹏920cpu 的 arm
kubectl ko 命令不起作用 脚本会根据 pod 使用的镜像来筛选出对应的 pod 然后执行对应的命令，因此当命令无法使用时，尝试修改一下脚本中的 REGISTRY
组件</description></item><item><title/><link>https://www.ryken.cloud/%E9%85%8D%E7%BD%AE-route-reflector/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E9%85%8D%E7%BD%AE-route-reflector/</guid><description>#calico #rr
Configuring Route Reflectors in Calico (tigera.io)
选择一个节点作为 RR，设置 lable 以及 routeReflectorClusterID 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 apiVersion:projectcalico.</description></item><item><title/><link>https://www.ryken.cloud/%E9%85%8D%E7%BD%AE-TOR/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E9%85%8D%E7%BD%AE-TOR/</guid><description>#calico #tor
配置其他节点连接到 RR 节点 1 2 3 4 5 6 7 apiVersion:projectcalico.org/v3kind:BGPPeermetadata:name:testspec:nodeSelector:all()peerSelector:has(routeReflector) 禁止 BGP FullMesh 1 2 3 4 5 6 7 8 apiVersion:projectcalico.</description></item><item><title/><link>https://www.ryken.cloud/%E9%97%AE%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.ryken.cloud/%E9%97%AE%E9%A2%98/</guid><description>为什么引入网卡多队列。引入网卡多队列解决了什么问题，带来了什么其他问题 队列绑核 整个收/发包的流程是什么样的 1.网卡多队列 &amp;ndash; 收包多队列 +发包多队列 通常情况下, 每张网卡有一个队列(queue), 所有收到的包从这个队列入, 内核从这个队列里取数据处理. 该队列其实是ring buffer(环形队列), 内核如果取数据不及时, 则会存在丢包的情况.
一个CPU处理一个队列的数据, 这个叫中断. 默认是cpu0(第一个CPU)处理. 一旦流量特别大, 这个CPU负载很高, 性能存在瓶颈.</description></item></channel></rss>